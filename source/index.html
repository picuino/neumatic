<!DOCTYPE html>
<html lang="es">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="keywords" content="Simulador Neumática Online">

  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <meta name="description" content="Simulador Neumático Online - Picuino">
  <title>Simulador Neumático - Picuino</title>

  <link rel="icon" type="image/png" sizes="192x192" href="/favicon-192.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96.png">
  <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48.png">

  <link rel="canonical" href="https://www.picuino.com/neumatic/index.html">

  <link rel="stylesheet" href="styles.css">
</head>

<body>

  <nav class="menu">
    <ul class="menu-principal">

      <li class="menu-item">
        <div class="menu-titulo">Archivo</div>
        <ul class="submenu">
          <li><a href="#" data-action="aNew">Nuevo Esquema</a></li>
          <li><a href="#" data-action="aOpen">Abrir Esquema</a></li>
          <li><a href="#" data-action="aSave">Guardar Esquema</a></li>
          <li><a href="#" data-action="aSavePNG">Guardar Imagen</a></li>
          <li><a href="#" data-action="about">Sobre...</a></li>
        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo">Dibujar</div>
        <ul class="submenu">
          
          <li class="has-submenu">
            <a href="#">Válvulas</a>
            <ul class="submenu">
              <li><a href="#" data-action="cValve22m">Válvula 2/2 manual</a></li>
              <li><a href="#" data-action="cValve32m">Válvula 3/2 manual</a></li>
              <li><a href="#" data-action="cValve32r">Válvula 3/2 con rodillo</a></li>
              <li><a href="#" data-action="cRoller">Rodillo de válvula</a></li>             
              <li><a href="#" data-action="cValve52m">Válvula 5/2 manual</a></li>
              <li><a href="#" data-action="cValve52p">Válvula 5/2 pilotada</a></li>
            </ul>
          </li>
          
          <li class="has-submenu">
            <a href="#">Válvulas Aux.</a>
            <ul class="submenu">
              <li><a href="#" data-action="cValveNret">Válvula antirretorno</a></li>
              <li><a href="#" data-action="cValveFlow">Válvula estranguladora</a></li>
              <li><a href="#" data-action="cValveOr">Válvula selectora (OR)</a></li>
              <li><a href="#" data-action="cValveAnd">Válvula de simultaneidad (AND)</a></li>
            </ul>
          </li>
          
          <li class="has-submenu">
            <a href="#">Cilindros</a>
            <ul class="submenu">
              <li><a href="#" data-action="cCylinder1">De simple efecto</a></li>
              <li><a href="#" data-action="cCylinder2">De doble efecto</a></li>
            </ul>
          </li>

          <li><a href="#" data-action="cPress">Presión</a></li>
          <li><a href="#" data-action="cPipe">Tubería</a></li>
          <li><a href="#" data-action="cEscape">Escape</a></li>
          <li><a href="#" data-action="cText">Texto</a></li>
          
        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo">Editar</div>
        <ul class="submenu">
          <li><a href="#" data-action="eDelete">Borrar</a></li>
          <li><a href="#" data-action="eMove">Mover</a></li>
          <li><a href="#" data-action="eEdit">Modificar</a></li>
        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo">Simular</div>
        <ul class="submenu">
          <li><a href="#" data-action="sInit">Iniciar</a></li>
          <li><a href="#" data-action="sStop">Detener</a></li>
          <li><a href="#" data-action="sContinue">Continuar</a></li>
        </ul>
      </li>

    </ul>
  </nav>

  <canvas id="canvas" class="canvas"></canvas>

  <dialog id="textPrompt">
    <form method="dialog">
      <p>Texto:</p>
      <input type="text" name="answer" id="textInput" placeholder="Text...">
      <div style="margin-top: 16px;">
        <button id="confirmBtn" value="default">Aceptar</button>
        <button id="cancelBtn" value="cancel" formnovalidate>Cancelar</button>
      </div>
    </form>
  </dialog>

  <dialog id="aboutWindow">
    <div>
    <h2>Picuino Pneumatic Simulator</h2>
    <p><strong>Copyright © 2025 Carlos Félix Pardo Martín.</strong></p>
    <p>
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.</p>
    <p>
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.</p>
    <p>
    You should have received a copy of the GNU General Public License
    along with this program. If not, see
    <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank">
    www.gnu.org/licenses/gpl-3.0.html</a>.</p>
    <button id="closeBtn">Cerrar</button>
    </div>
  </dialog>


<script>

/*
   Picuino Pneumatic Simulator.

   Copyright © 2025 Carlos Félix Pardo Martín.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program. If not, see <https://www.gnu.org/licenses/>.
*/

/* Global constants and variables */
const canvas = document.getElementById('canvas');
const grid = 10;
const lineWidth = 2;
const nearDist = 5;
const selectedColor = '#44f';
const defaultColor = '#000';
const textFont = '14px sans-serif';
const canvasScale = 2;
const airPressure = 1; // bar
const conductanceBase = 500;

let drawMode = null;
let componentType = null;
let componentMove = null;
let componentEdit = null;
let editPipe = null;
let pipeMove = null;
let initPos = null;
let endPos = null;
let running = false;


/*************************************************************************/

/* Menús y submenus */
document.addEventListener("click", (e) => {
  const trigger = e.target.closest(".menu-titulo, .has-submenu > a");

  // Click fuera del menú ? cerrar todo
  if (!trigger) {
    document.querySelectorAll(".submenu").forEach(sm =>
      sm.classList.remove("activo")
    );
    return;
  }

  e.preventDefault();
  e.stopPropagation();

  const submenu = trigger.nextElementSibling;
  if (!submenu || !submenu.classList.contains("submenu")) return;

  // Cerrar submenús hermanos
  const siblings = trigger.parentElement.parentElement
    .querySelectorAll(":scope > li > .submenu");

  siblings.forEach(sm => {
    if (sm !== submenu) sm.classList.remove("activo");
  });

  submenu.classList.toggle("activo");
});


/* menu actions */
document.addEventListener("click", (e) => {
  const item = e.target.closest("a[data-action]");
  if (!item) return;

  e.preventDefault();
  e.stopPropagation();

  const action = item.dataset.action;

  const actions = {
    aNew: () => { resetEditor() },
    aOpen: () => { openSchema(); },
    aSave: () => { saveSchema(); },
    aSavePNG: () => { savePNG(); },
    about: () => { aboutWindow(); },

    cPipe: () =>      { simulationStop(); drawMode='component'; componentType='Pipe'; },
    cPress: () =>     { simulationStop(); drawMode='component'; componentType='Compressor'; },
    cEscape: () =>    { simulationStop(); drawMode='component'; componentType='Escape'; },
    cText: () =>      { simulationStop(); drawMode='component'; componentType='Text'; },
    cValve22m: () =>  { simulationStop(); drawMode='component'; componentType='Valve22m'; },
    cValve32m: () =>  { simulationStop(); drawMode='component'; componentType='Valve32m'; },
    cValve32r: () =>  { simulationStop(); drawMode='component'; componentType='Valve32r'; },
    cRoller: () =>    { simulationStop(); drawMode='component'; componentType='Roller'; },
    cValve52m: () =>  { simulationStop(); drawMode='component'; componentType='Valve52m'; },
    cValve52p: () =>  { simulationStop(); drawMode='component'; componentType='Valve52p'; },
    cValveOr: () =>   { simulationStop(); drawMode='component'; componentType='ValveOr'; },
    cValveAnd: () =>  { simulationStop(); drawMode='component'; componentType='ValveAnd'; },
    cValveNret: () => { simulationStop(); drawMode='component'; componentType='ValveNret'; },
    cValveFlow: () => { simulationStop(); drawMode='component'; componentType='ValveFlow'; },
    cCylinder1: () => { simulationStop(); drawMode='component'; componentType='Cylinder1'; },
    cCylinder2: () => { simulationStop(); drawMode='component'; componentType='Cylinder2'; },

    eDelete: () => { simulationStop(); drawMode='Delete'; },
    eMove: () => { simulationStop(); drawMode='Move'; },
    eEdit: () => { simulationStop(); drawMode='Edit'; },

    sInit: () => { simulationInit(); },
    sStop: () => { simulationStop(); },
    sContinue: () => { simulationContinue(); },
  };

  actions[action]?.();

  // Cerrar todos los menús tras la acción
  document.querySelectorAll(".submenu").forEach(sm =>
    sm.classList.remove("activo")
  );
});


/*************************************************************************/
class ComponentBase {
  constructor(pos){
    this.timestamp = this.timestamp();
    this.x = snap(pos.x);
    this.y = snap(pos.y);
    this.type = 'ComponentBase';
    this.selected = false;
    this.color = defaultColor;
    this.grid = grid;
  }

  move(x, y) {
    this.x = snap(x, this.grid);
    this.y = snap(y, this.grid);   
  }
  
  timestamp() {
    const seconds = Math.floor(Date.now()*0.1);
    return seconds.toString(16).toUpperCase();
  }

  near() {
    return null;
  }

  nearPos(a, b) {
    if ((Math.abs(a.x - b.x) <= nearDist) && (Math.abs(a.y - b.y) <= nearDist)) {
       return true;
    }
    else {
      return null;
    }
  }

  nearRect(a_x, a_y, b_x, b_y, pos) {
    const minX = Math.min(a_x, b_x);
    const maxX = Math.max(a_x, b_x);
    const minY = Math.min(a_y, b_y);
    const maxY = Math.max(a_y, b_y);
    if (pos.x >= minX && pos.x <= maxX &&
        pos.y >= minY && pos.y <= maxY) {
      return true;
    }
  }

  draw(ctx){
  }

  drawPort(ctx, pos_x, pos_y, size_x, size_y) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.fillRect(pos_x-lineWidth, pos_y-lineWidth, lineWidth*2, lineWidth*2);
    ctx.strokeStyle = this.color;
    ctx.moveTo(pos_x, pos_y);
    ctx.lineTo(pos_x+size_x, pos_y+size_y);
    ctx.stroke();
  }

  drawArrow(ctx, init_x, init_y, end_x, end_y, color=this.color) {
    const arrowHeadSize = 8;
    const arrowAngle = Math.PI/10;
    const angle = Math.atan2(end_y - init_y, end_x - init_x);

    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(end_x - arrowHeadSize * Math.cos(angle),
               end_y - arrowHeadSize * Math.sin(angle));
    ctx.stroke();

	ctx.beginPath();
	ctx.fillStyle = color;
    ctx.moveTo(end_x, end_y);
    ctx.lineTo(end_x - arrowHeadSize * Math.cos(angle - arrowAngle),
               end_y - arrowHeadSize * Math.sin(angle - arrowAngle));
    ctx.lineTo(end_x - arrowHeadSize * Math.cos(angle + arrowAngle),
               end_y - arrowHeadSize * Math.sin(angle + arrowAngle));
    ctx.closePath();
	ctx.stroke();
    ctx.fill();
  }

  drawTap(ctx, init_x, init_y, end_x, end_y) {
    const tapSize = 5;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.strokeStyle = this.color;
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(end_x, end_y);
    ctx.moveTo(end_x-tapSize, end_y);
    ctx.lineTo(end_x+tapSize, end_y);
    ctx.stroke();
  }

  drawRectangle(ctx, init_x, init_y, end_x, end_y) {
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = this.color;
    ctx.strokeRect(init_x, init_y, end_x-init_x, end_y-init_y);
    ctx.stroke();
  }

  drawSpring(ctx, init_x, init_y) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.strokeStyle = this.color;
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(init_x+5, init_y-10);
    ctx.lineTo(init_x+10, init_y);
    ctx.lineTo(init_x+15, init_y-10);
    ctx.lineTo(init_x+20, init_y);
    ctx.stroke();
  }

  drawPushButton(ctx, init_x, init_y) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.strokeStyle = this.color;
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(init_x-20, init_y);
    ctx.lineTo(init_x-20, init_y-10);
    ctx.lineTo(init_x-13, init_y-10);
    ctx.lineTo(init_x-10, init_y-5);
    ctx.lineTo(init_x-7, init_y-10);
    ctx.lineTo(init_x, init_y-10);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(init_x-20, init_y+5);
    ctx.lineTo(init_x-20, init_y-15);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(init_x-10, init_y-15);
    ctx.lineTo(init_x-10, init_y-10);
    ctx.stroke();
  }
  
  drawPushRoller(ctx, init_x, init_y) {
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(init_x, init_y-4);
    ctx.lineTo(init_x-12, init_y-4);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(init_x, init_y+4);
    ctx.lineTo(init_x-12, init_y+4);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(init_x-16, init_y, 6, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(init_x-16, init_y, 1, 0, Math.PI*2);
    ctx.stroke();
  }

  update(engine, dt) {}

  serialize(){
    return {type:this.type, stamp:this.timestamp, x:this.x, y:this.y};
  }
}


class Text extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.x = snap(pos.x, grid*0.5);
    this.y = snap(pos.y, grid*0.5);
    this.type = 'Text';
    this.content = 'Text';
    this.grid = grid*0.5;
  }

  vias() {
    return [];
  }

  near(pos) {
    return this.nearRect(this.x+5, this.y-10, this.x+35, this.y+5, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    ctx.font = textFont;
    ctx.fillStyle = this.color;
    ctx.fillText(this.content, this.x+5, this.y+5);
  }

  serialize(){
    return {type:this.type, stamp:this.timestamp, x:this.x, y:this.y, content:this.content};
  }
}


class Pipe extends ComponentBase {
  constructor(posInit, posEnd) {
    super(posInit);
    this.type = 'Pipe';
    this.init = {x: snap(posInit.x), y: snap(posInit.y)};
    this.end = {x: snap(posEnd.x), y: snap(posEnd.y)};
    this.conductance = conductanceBase;
  }

  vias() {
    const via1 = this.init;
    const via2 = this.end;
    return [via1, via2];
  }

  update(engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const dpress = node1.pressure - node2.pressure;
    const q = dpress*this.conductance*dt;
    node1.addAir(-q);
    node2.addAir(q);
  }

  moveInit(pos) {
    this.init = {x: snap(pos.x), y: snap(pos.y)};
  }

  moveEnd(pos) {
    this.end = {x: snap(pos.x), y: snap(pos.y)};
  }

  near(pos) {
    if (this.nearPos(this.init, pos)) {
      return 'init';
    }
    if (this.nearPos(this.end, pos)) {
      return 'end';
    }
    return null;
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.fillRect(this.init.x-lineWidth, this.init.y-lineWidth, lineWidth*2, lineWidth*2);
    ctx.fillRect(this.end.x-lineWidth, this.end.y-lineWidth, lineWidth*2, lineWidth*2);
    ctx.moveTo(this.init.x, this.init.y);
    ctx.lineTo(this.end.x, this.end.y);
    ctx.stroke();
  };

  serialize(){
    return {type:this.type, stamp:this.timestamp, init:this.init, end:this.end};
  }
}


class Compressor extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Compressor';
    this.pressure = 6.0;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    return [via1];
  }

  update(engine, dt) {
    const [via1] = this.vias()
    const node = engine.findNode(via1);
    node.pressure = this.pressure;
  }

  near(pos) {
    return this.nearRect(this.x-8, this.y+5, this.x+8, this.y+25, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, 10);
    ctx.beginPath();
    ctx.arc(this.x,this.y+10+7,7,0,Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x,this.y+10+7,2,0,Math.PI*2);
    ctx.stroke();
  }
}


class ValveNret extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveNret';
    this.conductance = conductanceBase;
    this.minPressure = 0.1; // bar
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    return [via1, via2];
  }

  update(engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const dpress = node1.pressure - node2.pressure;
    if (dpress > this.minPressure) {
      const q = dpress*this.conductance*dt;
      node1.addAir(-q);
      node2.addAir(q);
    }
  }

  near(pos) {
    return this.nearRect(this.x-10, this.y-40, this.x+10, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x, this.y-50, 0, 10);
    this.drawValveNret(ctx);
  }

  drawValveNret(ctx) {
    ctx.beginPath();
    ctx.lineTo(this.x, this.y-10);
    ctx.lineTo(this.x, this.y-15);
    ctx.lineTo(this.x-10, this.y-25);
    ctx.lineTo(this.x, this.y-15);
    ctx.lineTo(this.x+10, this.y-25);
    ctx.stroke();

    ctx.beginPath();
    if (true) {
      ctx.arc(this.x,this.y-25, 6, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(this.x, this.y-31);
      ctx.lineTo(this.x, this.y-40);
      }
    else {
      ctx.beginPath();
      ctx.arc(this.x,this.y-30, 6, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(this.x, this.y-36);
      ctx.lineTo(this.x, this.y-40);
    }
    ctx.stroke();
  }
}


class ValveFlow extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveFlow';
    this.conductance = 1;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    return [via1, via2];
  }

  update(engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const dpress = node1.pressure - node2.pressure;
    const q = dpress*this.conductance*dt;
    node1.addAir(-q);
    node2.addAir(q);
  }

  near(pos) {
    return this.nearRect(this.x-15, this.y-40, this.x+15, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x, this.y-50, 0, 10);
    this.drawValveFlow(ctx);
  }

  drawValveFlow(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.x, this.y-10);
    ctx.lineTo(this.x, this.y-40);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x-25,this.y-25, 22, -Math.PI*0.16, Math.PI*0.16);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x+25,this.y-25, 22, Math.PI*0.84, Math.PI*1.16);
    ctx.stroke();
    this.drawArrow(ctx, this.x-18, this.y-15, this.x+18, this.y-35);
  }
}


class ValveOr extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveOr';
    this.shift = 0;
    this.maxShift = 28;
    this.conductance = conductanceBase;
  }
  
  vias() {
    const in1 = {x:this.x-40, y:this.y+30};
    const in2 = {x:this.x+40, y:this.y+30};
    const out = {x:this.x, y:this.y};
    return [in1, in2, out];
  }

  update(engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    
    if (this.shift === this.maxShift) {
      const dpress = node1.pressure - node3.pressure;
      const q = dpress*this.conductance*dt;
      node1.addAir(-q);
      node3.addAir(q);
    }
    if (this.shift === 0) {
      const dpress = node2.pressure - node3.pressure;
      const q = dpress*this.conductance*dt;
      node2.addAir(-q);
      node3.addAir(q);
    }
    if (this.shift === 0 && node1.pressure > node2.pressure + 0.1) {
      this.shift = this.maxShift;
    }
    if (this.shift === this.maxShift && node2.pressure > node1.pressure + 0.1) {
      this.shift = 0;
    }
  }

  near(pos) {
    return this.nearRect(this.x-30, this.y+15, this.x+30, this.y+45, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, 17);
    this.drawPort(ctx, this.x-40, this.y+30, 12, 0);
    this.drawPort(ctx, this.x+40, this.y+30, -12, 0);
    this.drawValveOr(ctx);
    this.drawMovement(ctx);
  }

  drawValveOr(ctx) {
    ctx.beginPath();
    ctx.moveTo(this.x-18, this.y+20);
    ctx.lineTo(this.x-28, this.y+30);
    ctx.lineTo(this.x-18, this.y+40);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x+18, this.y+20);
    ctx.lineTo(this.x+28, this.y+30);
    ctx.lineTo(this.x+18, this.y+40);
    ctx.stroke();

    this.drawRectangle(ctx, this.x-30, this.y+17, this.x+30, this.y+43);
  }

  drawMovement(ctx) {
    const posX = this.x + this.shift;
    ctx.beginPath();
    ctx.arc(posX-14,this.y+30, 8, 0, Math.PI*2);
    ctx.stroke();
  }
}


class ValveAnd extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveAnd';
    this.shift = 4;
    this.maxShift = 8;
    this.conductance = conductanceBase;
  }

  vias() {
    const in1 = {x:this.x-40, y:this.y+30};
    const in2 = {x:this.x+40, y:this.y+30};
    const out = {x:this.x, y:this.y};
    return [in1, in2, out];
  }

  update(engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    
    if (node1.pressure > node2.pressure + 0.1) {
      const dpress = node2.pressure - node3.pressure;
      const q = dpress*this.conductance*dt;
      node2.addAir(-q);
      node3.addAir(q);
      this.shift = this.maxShift;
    }
    if (node2.pressure > node1.pressure + 0.1) {
      const dpress = node1.pressure - node3.pressure;
      const q = dpress*this.conductance*dt;
      node1.addAir(-q);
      node3.addAir(q);
      this.shift = 0;
    }
  }

  near(pos) {
    return this.nearRect(this.x-30, this.y+15, this.x+30, this.y+45, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, 17);
    this.drawPort(ctx, this.x-40, this.y+30, 10, 0);
    this.drawPort(ctx, this.x+40, this.y+30, -10, 0);
    this.drawValveOr(ctx);
    this.drawMovement(ctx);
  }

  drawValveOr(ctx) {
    this.drawRectangle(ctx, this.x-30, this.y+17, this.x+30, this.y+43);

    ctx.beginPath();
    ctx.moveTo(this.x-15, this.y+17);
    ctx.lineTo(this.x-15, this.y+26);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x-15, this.y+43);
    ctx.lineTo(this.x-15, this.y+34);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x+15, this.y+17);
    ctx.lineTo(this.x+15, this.y+26);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x+15, this.y+43);
    ctx.lineTo(this.x+15, this.y+34);
    ctx.stroke();
  }
  
  drawMovement(ctx) {
    const posX = this.x + this.shift;
    ctx.beginPath();
    ctx.moveTo(posX-25, this.y+21);
    ctx.lineTo(posX-25, this.y+39);
    ctx.moveTo(posX-25, this.y+30);
    ctx.lineTo(posX+17, this.y+30);
    ctx.moveTo(posX+17, this.y+21);
    ctx.lineTo(posX+17, this.y+39);
    ctx.stroke();
  }
}


class Escape extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Escape';
    this.pressure = airPressure;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    return [via1];
  }
  

  update(engine, dt) {
    const [via1] = this.vias()
    const node = engine.findNode(via1);
    node.pressure = this.pressure;
  }

  near(pos) {
    return this.nearRect(this.x-5, this.y, this.x+5, this.y+18, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, 10);
    ctx.beginPath();
    ctx.moveTo(this.x,   this.y+10);
    ctx.lineTo(this.x-7, this.y+10);
    ctx.lineTo(this.x,   this.y+20);
    ctx.lineTo(this.x+7, this.y+10);
    ctx.lineTo(this.x,   this.y+10);
    ctx.stroke();
  }
}


class Cylinder1 extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Cylinder1';
    this.shift = 0;
    this.maxShift = 80;
    this.color = '#000';
    this.pressure = 1; // bar
    this.conductance = conductanceBase;
    this.position = {min:0, max:20, actual:0};
    this.volumeMin = 12; // cm3
    this.area = 12; // cm3
    this.springForce = 0.5; // kgf/cm
    this.springForceMin = 10; // kgf
    this.frictionForce = 0.1; // kgf
    this.pistonMass = 0.2; // kg
    this.speed = 0; // cm/s
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    return [via1];
  }

  update(engine, dt) {
    const [via1] = this.vias();
    const node1 = engine.findNode(via1);
 
    const volume = this.position.actual * this.area + this.volumeMin;
    const q = this.conductance * (node1.pressure - this.pressure);
    this.pressure += dt * (q - this.speed*this.pressure*this.area) / volume;
    const forceAir = this.area*(this.pressure-airPressure);
    const forceSpring = this.springForceMin + this.position.actual*this.springForce;
    let force = 0;
    if (this.speed === 0) {
      if (Math.abs(forceAir-forceSpring) > this.frictionForce) {
        if (forceAir - forceSpring > 0) {
          force = forceAir - forceSpring - this.frictionForce;
        }
        else {
          force = forceAir - forceSpring + this.frictionForce;        
        }
        this.speed += dt * force / this.pistonMass;
      }
    }
    else {
      force = forceAir - forceSpring + this.frictionForce*Math.sign(this.speed);
      this.speed += dt * force / this.pistonMass;
    }
    this.position.actual += this.speed * dt;
    if (this.position.actual < this.position.min) {
      this.position.actual = this.position.min;
      this.speed = 0;
    }
    if (this.position.actual > this.position.max) {
      this.position.actual = this.position.max;
      this.speed = 0;
    }
    this.shift = this.maxShift * (this.position.actual-this.position.min)/
                 (this.position.max - this.position.min);
  }

  near(pos) {
    return this.nearRect(this.x-5, this.y-40, this.x+95, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawRectangle(ctx, this.x-5, this.y-10, this.x+115, this.y-40);
    this.drawPiston(ctx, this.shift);
  }

  drawPiston(ctx, shift) {
    let posX = this.x + shift;
    this.drawRectangle(ctx, posX+5, this.y-10, posX+15, this.y-40);
    this.drawRectangle(ctx, posX+15, this.y-20, posX+125, this.y-30);
    this.drawRectangle(ctx, posX+125, this.y-15, posX+145, this.y-35);
    this.drawSpring(ctx, posX+15, this.y-13, this.x+115);
  }

  drawSpring(ctx, initX, initY, endX) {
    const step = (endX-initX)/6;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.lineJoin = 'round';
    ctx.moveTo(initX, initY);
    ctx.lineTo(initX+step, initY-24);
    ctx.lineTo(initX+step*2, initY+0);
    ctx.lineTo(initX+step*3, initY-24);
    ctx.lineTo(initX+step*4, initY+0);
    ctx.lineTo(initX+step*5, initY-24);
    ctx.lineTo(initX+step*6, initY+0);
    ctx.stroke();
    ctx.lineJoin = 'miter';
  }
}


class Cylinder2 extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Cylinder2';
    this.shift = 0;
    this.maxShift = 90;
    this.color = '#000';
    this.pressure1 = 1; // bar
    this.pressure2 = 1; // bar
    this.conductance = conductanceBase;
    this.position = {min:0, max:20, actual:0};
    this.volumeMin = 12;
    this.area1 = 12; // cm3
    this.area2 = 9; // cm3
    this.areaPiston = this.area1 - this.area2;
    this.frictionForce = 0.1; // kgf
    this.pistonMass = 0.2; // kg
    this.speed = 0; // cm/s
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x+110, y:this.y};
    return [via1, via2];
  }

  update(engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);

    const volume1 = this.position.actual * this.area1 + this.volumeMin;
    const volume2 = (this.position.max - this.position.actual) * this.area2 + this.volumeMin;

    const q1 = this.conductance * (node1.pressure - this.pressure1);
    const q2 = this.conductance * (node2.pressure - this.pressure2);
    const dp1 = dt * (q1 - this.speed*this.pressure1*this.area1) / volume1;
    this.pressure1 += dt * (q1 - this.speed*this.pressure1*this.area1) / volume1;
    this.pressure2 += dt * (q2 + this.speed*this.pressure2*this.area2) / volume2;
    const force1 = this.pressure1 * this.area1; // kgf
    const force2 = this.pressure2 * this.area2 + airPressure * this.areaPiston; // kgf
    let netForce = force1 - force2;

    if (this.speed === 0) {
      if (Math.abs(netForce) > this.frictionForce) {
        if (netForce > 0) {
          netForce -= this.frictionForce;
        }
        else {
          netForce += this.frictionForce;
        }
        this.speed += dt * netForce / this.pistonMass;
      }
    }
    else {
      netForce += this.frictionForce*Math.sign(this.speed);
      this.speed += dt * netForce / this.pistonMass;
    }

    this.position.actual += this.speed * dt;
    
    if (this.position.actual < this.position.min) {
      this.position.actual = this.position.min;
      this.speed = 0;
    }
    if (this.position.actual > this.position.max) {
      this.position.actual = this.position.max;
      this.speed = 0;
    }
    this.shift = this.maxShift * (this.position.actual-this.position.min)/
                 (this.position.max - this.position.min);
  }

  near(pos) {
    return this.nearRect(this.x-5, this.y-40, this.x+100, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x+110, this.y, 0, -10);
    this.drawRectangle(ctx, this.x-5, this.y-10, this.x+115, this.y-40);
    this.drawPiston(ctx, this.shift);
  }

  drawPiston(ctx, shift) {
    let posX = this.x + shift;
    this.drawRectangle(ctx, posX+5, this.y-10, posX+15, this.y-40);
    this.drawRectangle(ctx, posX+15, this.y-20, posX+125, this.y-30);
    this.drawRectangle(ctx, posX+125, this.y-15, posX+145, this.y-35);
  }
}


class Valve22m extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve22m';
    this.shift = {
      min: 0,
      max: 30,
      pos: 0,
      speed: 300,
    }
    this.conductance = conductanceBase;
    this.color = '#000';
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    return [via1, via2];
  }

  update(engine, dt) {
    if (this.shift.pos === this.shift.max) {
      const [via1, via2] = this.vias();
      const node1 = engine.findNode(via1);
      const node2 = engine.findNode(via2);
      const dpress = node1.pressure - node2.pressure;
      const q = dpress*this.conductance*dt;
      node1.addAir(-q);
      node2.addAir(q);
    }    
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }
  }

  near(pos) {
    return this.nearRect(this.x-45, this.y-40, this.x+15, this.y-10, pos);
  }

  nearPushButton(pos) {
    return this.nearRect(this.x-65+this.shift.pos, this.y-35,
                         this.x-45+this.shift.pos, this.y-15, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x, this.y-50, 0, 10);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    this.drawTap(ctx, posX, this.y-10, posX, this.y-20);
    this.drawTap(ctx, posX, this.y-40, posX, this.y-30);
    this.drawRectangle(ctx, posX-15, this.y-10, posX+15, this.y-40);

    this.drawArrow(ctx, posX-30, this.y-10, posX-30, this.y-40+lineWidth);
    this.drawRectangle(ctx, posX-45, this.y-10, posX-15, this.y-40);

    this.drawSpring(ctx, posX+15, this.y-20);
    this.drawPushButton(ctx, posX-45, this.y-20);
  }
}


class Valve32m extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve32m';
    this.shift = {
      min: 0,
      max: 40,
      pos: 0,
      speed: 300,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color = '#000';
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    const via3 = {x:this.x+20, y:this.y};
    return [via1, via2, via3];
  }

  update(engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    if (this.shift.pos === this.shift.min) {
      const dpress = node2.pressure - node3.pressure;
      const q = dpress*this.conductance*dt;
      node2.addAir(-q);
      node3.addAir(q);
    }
    if (this.shift.pos === this.shift.max) {
      const dpress = node1.pressure - node2.pressure;
      const q = dpress*this.conductance*dt;
      node1.addAir(-q);
      node2.addAir(q);
    }    
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }
  }

  near(pos) {
    return this.nearRect(this.x-50, this.y-40, this.x+30, this.y-10, pos);
  }

  nearPushButton(pos) {
    return this.nearRect(this.x-70+this.shift.pos, this.y-35, this.x-50+this.shift.pos, this.y-15, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x, this.y-50, 0, 10);
    this.drawPort(ctx, this.x+20, this.y, 0, -10);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    this.drawArrow(ctx, posX, this.y-40, posX+20, this.y-10-lineWidth);
    this.drawTap(ctx, posX, this.y-10, posX, this.y-20);
    this.drawRectangle(ctx, posX-10, this.y-10, posX+30, this.y-40);

    this.drawArrow(ctx, posX-40, this.y-10, posX-40, this.y-40+lineWidth);
    this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    this.drawRectangle(ctx, posX-50, this.y-10, posX-10, this.y-40);

    this.drawSpring(ctx, posX+30, this.y-20);
    this.drawPushButton(ctx, posX-50, this.y-20);
  }
}


class Valve32r extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve32r';
    this.content = '1.1';
    this.shift = 0;
    this.maxShift = 40;
    this.color = '#000';
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    const via3 = {x:this.x+20, y:this.y};
    return [via1, via2, via3];
  }

  update(engine, dt) {
  }

  near(pos) {
    return this.nearRect(this.x-50, this.y-40, this.x+30, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x, this.y-50, 0, 10);
    this.drawPort(ctx, this.x+20, this.y, 0, -10);
    this.drawBody(ctx, this.shift);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    this.drawArrow(ctx, posX, this.y-40, posX+20, this.y-10-lineWidth);
    this.drawTap(ctx, posX, this.y-10, posX, this.y-20);
    this.drawRectangle(ctx, posX-10, this.y-10, posX+30, this.y-40);

    this.drawArrow(ctx, posX-40, this.y-10, posX-40, this.y-40+lineWidth);
    this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    this.drawRectangle(ctx, posX-50, this.y-10, posX-10, this.y-40);

    this.drawSpring(ctx, posX+30, this.y-20);
    this.drawPushRoller(ctx, posX-50, this.y-25);
    
    ctx.font = textFont;
    ctx.fillStyle = this.color;
    ctx.textAlign = "center";
    ctx.fillText(this.content.slice(0, 3), posX-66, this.y-35);
    ctx.textAlign = "start";
  }
}


class Roller extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Roller';
    this.content = '1.1';
    this.shift = 0;
    this.maxShift = 10;
    this.color = '#000';
  }

  vias() {
    return [];
  }

  update(engine, dt) {
  }

  near(pos) {
    return this.nearRect(this.x-15, this.y-40, this.x+15, this.y, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawRectangle(ctx, this.x-15, this.y-40, this.x+15, this.y-20);

    ctx.font = textFont;
    ctx.fillStyle = this.color;
    ctx.textAlign = "center";
    ctx.fillText(this.content.slice(0, 3), this.x, this.y-25);
    ctx.textAlign = "start";
    
    let posY = this.y - this.shift;
    ctx.beginPath();
    ctx.moveTo(this.x-4, posY-4);
    ctx.lineTo(this.x-4, this.y-20);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(this.x+4, posY-4);
    ctx.lineTo(this.x+4, this.y-20);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(this.x, posY, 6, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x, posY, 1, 0, Math.PI*2);
    ctx.stroke();
  }
}


class Valve52m extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve52m';
    this.shift = {
      min: 0,
      max: 60,
      pos: 0,
      speed: 300,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color = '#000';
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x-20, y:this.y};
    const via3 = {x:this.x+20, y:this.y};
    const via4 = {x:this.x-20, y:this.y-50};
    const via5 = {x:this.x+20, y:this.y-50};
    return [via1, via2, via3, via4, via5];
  }

  update(engine, dt) {
    const [via1, via2, via3, via4, via5] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    const node4 = engine.findNode(via4);
    const node5 = engine.findNode(via5);
    if (this.shift.pos === this.shift.min) {
      const dpress1 = node1.pressure - node5.pressure;
      const q1 = dpress1*this.conductance*dt;
      node1.addAir(-q1);
      node5.addAir(q1);
      
      const dpress2 = node2.pressure - node4.pressure;
      const q2 = dpress2*this.conductance*dt;
      node2.addAir(-q2);
      node4.addAir(q2);
    }
    if (this.shift.pos === this.shift.max) {
      const dpress1 = node1.pressure - node4.pressure;
      const q1 = dpress1*this.conductance*dt;
      node1.addAir(-q1);
      node4.addAir(q1);

      const dpress2 = node3.pressure - node5.pressure;
      const q2 = dpress2*this.conductance*dt;
      node3.addAir(-q2);
      node5.addAir(q2);
    }    
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }
  }

  near(pos) {
    return this.nearRect(this.x-90, this.y-40, this.x+30, this.y-10, pos);
  }

  nearPushButton(pos) {
    return this.nearRect(this.x-110+this.shift.pos, this.y-35, this.x-90+this.shift.pos, this.y-15, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x+20, this.y, 0, -10);
    this.drawPort(ctx, this.x-20, this.y, 0, -10);
    this.drawPort(ctx, this.x+20, this.y-50, 0, 10);
    this.drawPort(ctx, this.x-20, this.y-50, 0, 10);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    this.drawArrow(ctx, posX, this.y-10, posX+20, this.y-40+lineWidth);
    this.drawArrow(ctx, posX-20, this.y-40, posX-20, this.y-10-lineWidth);
    this.drawTap(ctx, posX+20, this.y-10, posX+20, this.y-20);
    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);

    this.drawSpring(ctx, posX+30, this.y-20);

    posX -= 60;
    this.drawArrow(ctx, posX, this.y-10, posX-20, this.y-40+lineWidth);
    this.drawArrow(ctx, posX+20, this.y-40, posX+20, this.y-10-lineWidth);
    this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);

    this.drawPushButton(ctx, posX-30, this.y-20);
  }
}


class Valve52p extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve52p';
    this.shift = {
      min: 0,
      max: 60,
      pos: 0,
      speed: 300,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color = '#000';    
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x-20, y:this.y};
    const via3 = {x:this.x+20, y:this.y};
    const via4 = {x:this.x-20, y:this.y-50};
    const via5 = {x:this.x+20, y:this.y-50};
    const via6 = {x:this.x-110, y:this.y-20};
    const via7 = {x:this.x+110, y:this.y-20};
    return [via1, via2, via3, via4, via5, via6, via7];
  }

  update(engine, dt) {
    const [via1, via2, via3, via4, via5, via6, via7] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    const node4 = engine.findNode(via4);
    const node5 = engine.findNode(via5);
    const node6 = engine.findNode(via6);
    const node7 = engine.findNode(via7);

    if (this.active && node7.pressure > node6.pressure + 0.1) {
       this.active = false;
    }
    if (!this.active && node6.pressure > node7.pressure + 0.1) {
       this.active = true;
    }
    
    if (this.shift.pos === this.shift.min) {
      const dpress1 = node1.pressure - node5.pressure;
      const q1 = dpress1*this.conductance*dt;
      node1.addAir(-q1);
      node5.addAir(q1);
      
      const dpress2 = node2.pressure - node4.pressure;
      const q2 = dpress2*this.conductance*dt;
      node2.addAir(-q2);
      node4.addAir(q2);
    }
    if (this.shift.pos === this.shift.max) {
      const dpress1 = node1.pressure - node4.pressure;
      const q1 = dpress1*this.conductance*dt;
      node1.addAir(-q1);
      node4.addAir(q1);

      const dpress2 = node3.pressure - node5.pressure;
      const q2 = dpress2*this.conductance*dt;
      node3.addAir(-q2);
      node5.addAir(q2);
    }    
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }
  }

  near(pos) {
    return this.nearRect(this.x-90, this.y-40, this.x+30, this.y-10, pos);
  }


  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10);
    this.drawPort(ctx, this.x+20, this.y, 0, -10);
    this.drawPort(ctx, this.x-20, this.y, 0, -10);
    this.drawPort(ctx, this.x+20, this.y-50, 0, 10);
    this.drawPort(ctx, this.x-20, this.y-50, 0, 10);
    this.drawPort(ctx, this.x-110, this.y-20, 6, 0);
    this.drawPort(ctx, this.x+110, this.y-20, -6, 0);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    this.drawArrow(ctx, posX, this.y-10, posX+20, this.y-40+lineWidth);
    this.drawArrow(ctx, posX-20, this.y-40, posX-20, this.y-10-lineWidth);
    this.drawTap(ctx, posX+20, this.y-10, posX+20, this.y-20);
    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);

    this.drawRectangle(ctx, posX+30, this.y-27, posX+44, this.y-13);
    ctx.beginPath();
    ctx.moveTo(posX+44, this.y-27);
    ctx.lineTo(posX+34, this.y-20);
    ctx.lineTo(posX+44, this.y-13);
    ctx.moveTo(posX+44, this.y-20);
    ctx.lineTo(this.x+110, this.y-20);
    ctx.stroke();

    posX -= 60;
    this.drawArrow(ctx, posX, this.y-10, posX-20, this.y-40+lineWidth);
    this.drawArrow(ctx, posX+20, this.y-40, posX+20, this.y-10-lineWidth);
    this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);

    this.drawRectangle(ctx, posX-30, this.y-27, posX-44, this.y-13);
    ctx.beginPath();
    ctx.moveTo(posX-44, this.y-27);
    ctx.lineTo(posX-34, this.y-20);
    ctx.lineTo(posX-44, this.y-13);
    ctx.moveTo(posX-44, this.y-20);
    ctx.lineTo(this.x-110, this.y-20);
    ctx.stroke();
  }
}


/*************************************************************************/

class Node {
  constructor(pos) {
    this.volume = 10; // cm3
    this.pressure = airPressure; // bar
    this.x = pos.x;
    this.y = pos.y;
  }
  
  addAir(q) {
    if (Number.isNaN(q)) {
      console.log('NaN node', this.x, this.y);
      return;
    }
    this.pressure += q / this.volume;
  }
}


class Engine {

  constructor() {
    this.components = [];
    this.nodes = [];
  }

  render(dt) {
    for (const comp of this.components) {
      comp.update(this, dt);
    }
  }
  
  createNodes() {
    this.nodes = [];
    for (const comp of this.components) {
      for (const pos of comp.vias()) {
        if (this.findNode(pos) === null) {
          const newnode = new Node(pos);
          this.nodes.push(newnode);
        }
      }
    }
  }

  findNode(pos) {
    for (const node of this.nodes) {
      if ((node.x === pos.x) && (node.y === pos.y)) {
        return node;
      }
    }
    return null;
  }

  addComponent(comp){
    this.components.push(comp);
  }

  deleteComponent(comp) {
    const index = this.components.indexOf(comp);
    this.components.splice(index, 1);
  }

  reset() {
    this.components = [];
  }

  step(){
  }
}


/*************************************************************************/

class Renderer{
  constructor(canvas, engine){
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.engine = engine;
    this.selectedId = null;
  }

  draw() {
    const ctx = this.ctx;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    ctx.textAlign = "start";
    ctx.font = textFont;
    ctx.fillStyle = '#aaa';
    ctx.fillText('PICUINO PNEUMATIC SIMULATOR', 12, 18);
    
    ctx.lineWidth = lineWidth;
    for (const comp of this.engine.components) {
      comp.draw(ctx);
    }
  }

  drawPosition(position) {
    const ctx = this.ctx;
    ctx.fillStyle = '#fff';
    ctx.fillRect(this.canvas.width*0.5-80, 5, 80, 18);
    ctx.font = textFont;
    ctx.fillStyle = '#aaa';
    ctx.fillText(position.x +', '+ position.y, this.canvas.width*0.5-80, 18);
  }
}



/*************************************************************************/

class UIController {
  constructor(canvas, engine, renderer) {
    this.canvas = canvas;
    this.engine = engine;
    this.renderer = renderer;
    this.grid = grid;
    this.offset = {x:0, y:0};
    this.inspector = document.getElementById('props');
    this.pendingPort = null;

    this.canvas.addEventListener('mousedown', e=> this._onDown(e));
    window.addEventListener('mousemove', e=> this._onMove(e));
    window.addEventListener('mouseup', e=> this._onUp(e));
    window.addEventListener("resize", e=> this._resizeCanvas());
    document.addEventListener("keydown", event => {
      if (event.key === "Escape") { this._escape(); }
      if (event.key === "Delete") { this._delete(); }
      this.renderer.draw();
    });

    this._resizeCanvas();
  }

  _delete() {
    if ((drawMode === 'Move') && (componentMove)) {
       this.engine.deleteComponent(componentMove);
       this.renderer.draw();
    }
  }

  _escape() {
    drawMode = null;
    componentMove = null;
    if (editPipe) {
      this.engine.deleteComponent(editPipe)
    }
    editPipe = null;
    pipeMove = null;
    initPos = null;
    this.renderer.draw();
  }

  _resizeCanvas(e) {
    const canvas = this.canvas;
    const ctx = canvas.getContext('2d');
    canvas.width  = window.innerWidth*canvasScale;
    canvas.height = window.innerHeight*canvasScale - 35;
    canvas.style.width = this.canvas.width/canvasScale + 'px';
    canvas.style.height  = this.canvas.height/canvasScale + 'px';
    ctx.scale(canvasScale, canvasScale);
    this.renderer.draw();
  }

  _getMousePos(e) {
    const r = this.canvas.getBoundingClientRect();
    let xPos = e.clientX - r.left;
    let yPos = e.clientY - r.top;
    return {x: xPos, y: yPos};
  }

  _onDown(e) {
    let position = this._getMousePos(e);

    // Activate manual valves
    for (const comp of this.engine.components) {
      if (['Valve32m', 'Valve22m', 'Valve52m'].includes(comp.type) 
          && comp.nearPushButton(position)) {
        if (comp.active) comp.active = false;
        else comp.active = true;
      }
    }
    
    // Edit component mode
    if (drawMode === 'Edit') {
      componentEdit = null;
      for (const comp of this.engine.components) {
        if (comp.near(position) && comp.type === 'Text') {
          componentEdit = comp;
          break;
        }
      }
      if (componentEdit) {
        fillText(componentEdit);
      }
    }

    // Delete component mode
    if (drawMode === 'Delete') {
      let deleteComp = null;
      for (const comp of this.engine.components) {
        if (comp.near(position)) {
          deleteComp = comp;
          break;
        }
      }
      if (deleteComp) {
        this.engine.deleteComponent(deleteComp);
        this.renderer.draw();
      }
    }


    // Draw component mode
    if (drawMode === 'component') {
      let comp = null;
      if (componentType === 'Compressor') comp = new Compressor(position);
      if (componentType === 'Escape') comp = new Escape(position);
      if (componentType === 'Text') comp = new Text(position);
      if (componentType === 'Cylinder1') comp = new Cylinder1(position);
      if (componentType === 'Cylinder2') comp = new Cylinder2(position);
      if (componentType === 'Valve22m') comp = new Valve22m(position);
      if (componentType === 'Valve32m') comp = new Valve32m(position);
      if (componentType === 'Valve32r') comp = new Valve32r(position);
      if (componentType === 'Roller') comp = new Roller(position);
      if (componentType === 'Valve52m') comp = new Valve52m(position);
      if (componentType === 'Valve52p') comp = new Valve52p(position);
      if (componentType === 'ValveNret') comp = new ValveNret(position);
      if (componentType === 'ValveFlow') comp = new ValveFlow(position);
      if (componentType === 'ValveOr') comp = new ValveOr(position);
      if (componentType === 'ValveAnd') comp = new ValveAnd(position);

      // Draw Text
      if (componentType === 'Text') {
	    fillText(comp);
	  }
	  
      // Draw pipe
      if (componentType === 'Pipe') {
        if (initPos === null) {
          initPos = position;
          editPipe = new Pipe(initPos, initPos);
          comp = editPipe;
          editPipe.color = selectedColor;
        }
        else {
          editPipe.moveEnd(position);
          editPipe.color = '#000';
          if (editPipe.init.x === editPipe.end.x &&
              editPipe.init.y === editPipe.end.y) {
            this.engine.deleteComponent(editPipe);
          }
          editPipe = null;
          initPos = null;
          this.renderer.draw();
        }
      }

    // Add component and redraw
      if (comp !== null) {
        this.engine.addComponent(comp);
      }
      this.renderer.draw();
    }

    // Move component mode
    if (drawMode === 'Move') {
      if (componentMove !== null) {
        componentMove.color = '#000';
        if (pipeMove === 'init')
          componentMove.moveInit(position);
        else if (pipeMove === 'end') 
          componentMove.moveEnd(position);
        else {
          componentMove.move(position.x, position.y);
        }
        componentMove = null;
        pipeMove = null;
      }
      else {
        for (const comp of this.engine.components) {
          const near = comp.near(position);
          if (near) {
            componentMove = comp;
            componentMove.color = selectedColor;
            if (componentMove.type === 'Pipe') {
              pipeMove = near;
            }
            break;
          }
        }
      }
      this.renderer.draw();
    }
  }

  _onMove(e){
    let position = this._getMousePos(e);
    
    this.renderer.drawPosition(position);

    if ((drawMode === 'component') && (componentType === 'Pipe') && (initPos !== null)) {
      editPipe.moveEnd(position);
      this.renderer.draw();
    }

    if ((drawMode === 'Move') && (componentMove)) {
      if (pipeMove === 'init') {
        componentMove.moveInit(position);
      }
      else if (pipeMove === 'end') {
        componentMove.moveEnd(position);
      }
      else {
        componentMove.move(position.x, position.y);
      }
      this.renderer.draw();
    }
  }

  _onUp(e){
    this.dragging = null;
  }

  _updateInspector(){
    const id = this.renderer.selectedId;
    if(!id){ this.inspector.textContent = '(Selecciona un componente)'; return; }
    const comp = this.engine.components[id];
    this.inspector.textContent = JSON.stringify(comp.serialize(),null,2);
  }
}

/*************************************************************************/

/*
  cyrb53 (c) 2018 bryc (github.com/bryc)
  License: Public domain (or MIT if needed). Attribution appreciated.
  A fast and simple 53-bit string hash function with decent collision resistance.
  Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
*/
function cyrb53(str, seed = 0) {
  let h1 = 0xdeadbeef ^ seed;
  let h2 = 0x41c6ce57 ^ seed;
  for(let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1  = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
  h2  = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
  const hash = 4294967296 * (2097151 & h2) + (h1 >>> 0);
  return hash.toString(16).toUpperCase();
};



/************************ FILE OPERATIONS ************************/

function aboutWindow() {
  console.log("Simulador de Neumática. Copyright © 2025 Carlos Félix Pardo Martín.");
  modal.showModal();
}

function resetEditor() {
   engine.reset();
   renderer.draw();
}

function loadSchema(schematicJSON) {
  if (!schematicJSON) return;
  const data = JSON.parse(schematicJSON);
  const header = data.slice(0, 1)[0];
  const schematic = data.slice(1, -1);
  const footer = data.slice(-1)[0];
  const hashData = cyrb53(JSON.stringify(data.slice(0, -1)));
  if (footer.hash !== hashData) {
     console.log('Corrupted file!');
     return;
  }

  let components = [];
  for (const comp of schematic) {
    newcomp = null;
    if (comp.type === 'Compressor') newcomp = new Compressor({x:comp.x, y:comp.y});
    if (comp.type === 'Escape')     newcomp = new Escape({x:comp.x, y:comp.y});
    if (comp.type === 'Cylinder1')  newcomp = new Cylinder1({x:comp.x, y:comp.y});
    if (comp.type === 'Cylinder2')  newcomp = new Cylinder2({x:comp.x, y:comp.y});
    if (comp.type === 'Valve22m')   newcomp = new Valve22m({x:comp.x, y:comp.y});
    if (comp.type === 'Valve32m')   newcomp = new Valve32m({x:comp.x, y:comp.y});
    if (comp.type === 'Valve32r')   newcomp = new Valve32r({x:comp.x, y:comp.y});
    if (comp.type === 'Valve52m')   newcomp = new Valve52m({x:comp.x, y:comp.y});
    if (comp.type === 'Valve52p')   newcomp = new Valve52p({x:comp.x, y:comp.y});
    if (comp.type === 'ValveNret')  newcomp = new ValveNret({x:comp.x, y:comp.y});
    if (comp.type === 'ValveFlow')  newcomp = new ValveFlow({x:comp.x, y:comp.y});
    if (comp.type === 'ValveOr')    newcomp = new ValveOr({x:comp.x, y:comp.y});
    if (comp.type === 'ValveAnd')   newcomp = new ValveAnd({x:comp.x, y:comp.y});
    if (comp.type === 'Pipe')       newcomp = new Pipe(comp.init, comp.end);
    if (comp.type === 'Roller') {
      newcomp = new Roller({x:comp.x, y:comp.y});
      newcomp.content = comp.content;
    }
    if (comp.type === 'Text') {
      newcomp = new Text({x:comp.x, y:comp.y});
      newcomp.content = comp.content;
    }
    if (newcomp) {
      newcomp.timestamp = comp.stamp;
      components.push(newcomp);
    }
  }
  engine.components = components;
  renderer.draw();
}


async function openSchema() {
  let schematic = null;
  const input = document.createElement('input');
  input.type = 'file';
  input.onchange = async (e) => {
    const file = e.target.files[0];
    const schematic = await file.text();
    loadSchema(schematic);
  };
  input.click();
  engine.createNodes();
}


function savePNG() {
  renderer.draw();
  
  const dataURL = canvas.toDataURL('image/png');
  const enlaceDescarga = document.createElement('a');
  enlaceDescarga.href = dataURL;
  enlaceDescarga.download = 'neumatic.png';
  enlaceDescarga.style.display = 'none';
  document.body.appendChild(enlaceDescarga);
  enlaceDescarga.click();
  document.body.removeChild(enlaceDescarga);
  URL.revokeObjectURL(enlaceDescarga);
}


function saveSchema() {
  let schematic = [{
    type: 'Schematic',
    program: 'Pneumatic Simulator Picuino',
    version: '25.12.19',
  }];
  for (const comp of engine.components) {
    schematic.push(comp.serialize());
  }
  schematicJSON = JSON.stringify(schematic);
  const hash = cyrb53(schematicJSON);
  schematic.push({type:'hash', hash});
  schematicJSONHash = JSON.stringify(schematic);

  const blob = new Blob([schematicJSONHash], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const enlaceDescarga = document.createElement('a');
  enlaceDescarga.href = url;
  enlaceDescarga.download = 'neumatic.txt';
  enlaceDescarga.style.display = 'none';
  document.body.appendChild(enlaceDescarga);
  enlaceDescarga.click();
  document.body.removeChild(enlaceDescarga);
  URL.revokeObjectURL(url);
}

/************************ SIMULATION ************************/

function simulationInit() {
  drawMode = null;
  engine.createNodes();
  animationID = requestAnimationFrame(simulationRender);
}


function simulationStop() {
  drawMode = null;
  if (animationID !== null) {
    cancelAnimationFrame(animationID);
    animationID = null;
  }
}


function simulationContinue() {
  drawMode = null;
  if (animationID === null) {
    animationID = requestAnimationFrame(simulationRender);
  }  
}


function simulationRender(ms) {
  if (ms - simulationTime > 100) {
    simulationTime = ms - 100;
  }
   
  // Ejecutar tantos pasos de 1 ms como quepan en el tiempo acumulado
  while (simulationTime < ms) {
    engine.render(0.010);
    simulationTime += 10;
  }

  // Aquí solo dibujas el estado actual (una vez por frame)
  renderer.draw();

  if (animationID)
    requestAnimationFrame(simulationRender);
}

let animationID = null;
let simulationTime = performance.now();
let accumulator = 0;

/************************ MAIN ************************/

const modal = document.getElementById('aboutWindow');
const close = document.getElementById('closeBtn');
const textPrompt = document.getElementById('textPrompt');
const textInput = document.getElementById('textInput');

const engine = new Engine();
const renderer = new Renderer(canvas, engine);
const ui = new UIController(canvas, engine, renderer);
let last = performance.now();

close.onclick = () => modal.close();


function snap(v, gr=grid) {
  return Math.round(v/gr)*gr;
}


function fillText(componentEdit) {
  textPromptDialog(componentEdit.content);
  
  textPrompt.addEventListener('close', () => {
    if (textPrompt.returnValue !== 'cancel' && componentEdit) {
      const text = textInput.value.trim();
      if (text.length >= 1) {
        componentEdit.content = text;
      }
      renderer.draw();
      componentEdit = null;
    }
  });
}

function textPromptDialog(content='Text') {
  textInput.value = content;
  textPrompt.showModal();
}

</script>

</body>
</html>