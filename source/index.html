<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="keywords" content="Online Pneumatic Simulator Schematic Picuino">

  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <meta name="description" content="Picuino Pneumatic Simulator">
  <title data-i18n="title">Pneumatic Simulator - Picuino</title>

  <link rel="icon" type="image/png" sizes="192x192" href="/favicon-192.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96.png">
  <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48.png">

  <link rel="canonical" href="https://www.picuino.com/neumatic/index.html">

  <style>
  body {
    margin: 0;
    padding-top: 35px;
    font-family: sans-serif;
    font-size: 14px;
  }

  .menu {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background: white;
    border-bottom: 1px solid #000;
    z-index: 1000;
  }

  .menu-principal {
    list-style: none;
    margin: 0;
    padding: 0 0;
    display: flex;
  }

  .menu-item {
    position: relative;
  }

  .menu-titulo {
    padding: 8px 8px;
    cursor: pointer;
    user-select: none;
    font-weight: bold;
    display: flex;
  }

  /* Submenú */
  .submenu {
    list-style: none;
    margin: 0;
    padding: 0;

    position: absolute;
    top: 100%;
    left: 0;

    width: fit-content;
    white-space: nowrap;
    background: white;
    border: 1px solid #ccc;

    display: none;
  }

  .submenu li {
    position: relative;
  }

  .submenu .submenu {
    top: 0;
    left: 100%;
  }

  .submenu li a {
    white-space: nowrap;
    display: block;
    padding: 10px;
    text-decoration: none;
    color: #333;
  }

  .submenu li a:hover {
    background: #f0f0f0;
  }

  .submenu li.has-submenu > a {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    position: relative;
  }

  .has-submenu > a::after {
    content: ">";
    margin-left: auto;
    padding-left: 8px;
  }

  .submenu.activo {
    display: block;
  }

  .canvas {
    display:block;
    background:#f8f8f8;
  }

  .inspector {
    width:220px;
    padding:10px;
    background:#fafafa;
    border-left:1px solid #eee;
  }

  dialog {
    margin-top: 40px;
    margin-bottom: auto;
    margin-left: auto;
    margin-right: auto;
    max-width:640px;

    position: fixed;
    top: 0;
    max-height: calc(100vh - 80px);
    overflow-y: auto;

    padding: 16px;
    border-radius: 8px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  }
  </style>
</head>

<body>

  <nav class="menu">
    <ul class="menu-principal">

      <li class="menu-item">
        <div class="menu-titulo" data-i18n="fileMenu">File</div>
        <ul class="submenu">

          <li><a href="#" data-action="fSwap"   data-i18n="fSwap">Swap Screen</a></li>

          <li class="has-submenu">
            <a href="#" data-i18n="languageMenu">Language</a>
            <ul class="submenu">
              <li><a href="#" data-action="enLang" data-i18n="enLang">English</a></li>
              <li><a href="#" data-action="esLang" data-i18n="esLang">Spanish</a></li>
            </ul>
          </li>

          <li><a href="#" data-action="fNew"   data-i18n="fNew">New Schematic</a></li>
          <li><a href="#" data-action="fOpen"  data-i18n="fOpen">Open Schematic</a></li>

          <li class="has-submenu">
            <a href="#" data-i18n="fSave">Save Schematic</a>
            <ul class="submenu">
              <li><a href="#" data-action="fSaveStudent" data-i18n="fSaveStudent">Student</a></li>
              <li><a href="#" data-action="fSaveTeacher" data-i18n="fSaveTeacher">Teacher</a></li>
            </ul>
          </li>

          <li><a href="#" data-action="fSavePNG" data-i18n="fSavePNG">Save Image</a></li>

          <li><a href="#" data-action="fAbout" data-i18n="fAbout">About...</a></li>
        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo" data-i18n="drawMenu">Draw</div>
        <ul class="submenu">

          <li class="has-submenu">
            <a href="#" data-i18n="valvesMenu">Valves</a>
            <ul class="submenu">
              <li><a href="#" data-action="cValve22m" data-i18n="cValve22m">Valve 2/2 manual</a></li>
              <li><a href="#" data-action="cValve32m" data-i18n="cValve32m">Valve 3/2 manual</a></li>
              <li><a href="#" data-action="cValve32r" data-i18n="cValve32r">Valve 3/2 with roller</a></li>
              <li><a href="#" data-action="cRoller"   data-i18n="cRoller">Roller of valve</a></li>
              <li><a href="#" data-action="cValve52m" data-i18n="cValve52m">Valve 5/2 manual</a></li>
              <li><a href="#" data-action="cValve52p" data-i18n="cValve52p">Valve 5/2 pneu. pilot</a></li>
            </ul>
          </li>

          <li class="has-submenu">
            <a href="#" data-i18n="auxValvesMenu">Aux. valves</a>
            <ul class="submenu">
              <li><a href="#" data-action="cValveNret" data-i18n="cValveNret">Non-return valve</a></li>
              <li><a href="#" data-action="cValveFlow" data-i18n="cValveFlow">Choke valve</a></li>
              <li><a href="#" data-action="cValveOr"   data-i18n="cValveOr">Or valve</a></li>
              <li><a href="#" data-action="cValveAnd"  data-i18n="cValveAnd">And valve</a></li>
            </ul>
          </li>

          <li class="has-submenu">
            <a href="#" data-i18n="cylinderMenu">Cylinder</a>
            <ul class="submenu">
              <li><a href="#" data-action="cCylinder1" data-i18n="cCylinder1">Single-acting</a></li>
              <li><a href="#" data-action="cCylinder2" data-i18n="cCylinder2">Double-acting</a></li>
            </ul>
          </li>

          <li><a href="#" data-action="cPress"  data-i18n="cPress">Compressor</a></li>
          <li><a href="#" data-action="cPipe"   data-i18n="cPipe">Pipe</a></li>
          <li><a href="#" data-action="cEscape" data-i18n="cEscape">Escape</a></li>
          <li><a href="#" data-action="cText"   data-i18n="cText">Text</a></li>

        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo" data-i18n="examplesMenu">Examples</div>
        <ul class="submenu">

          <li class="has-submenu">
            <a href="#" data-i18n="singleMenu">Single</a>
            <ul class="submenu">
              <li><a href="./index.html?loadFile=single-22.txt" target="_blank" data-i18n="eSingle01">Valve 2/2</a></li>
              <li><a href="./index.html?loadFile=single-32.txt" target="_blank" data-i18n="eSingle02">Valve 3/2</a></li>
            </ul>
          </li>

          <li class="has-submenu">
            <a href="#" data-i18n="doubleMenu">Double</a>
            <ul class="submenu">
              <li><a href="./index.html?loadFile=double-52-auto.txt" target="_blank" data-i18n="eDouble01">Valve 5/2 + Roller</a></li>
            </ul>
          </li>

          <li class="has-submenu">
            <a href="#" data-i18n="multipleMenu">Multiple</a>
            <ul class="submenu">
              <!-- <li><a href="./index.html?loadFile=single-22.txt" target="_blank" data-i18n="eSingle01">Valve 5/2 + Roller</a></li> -->
            </ul>
          </li>

        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo" data-i18n="editMenu">Edit</div>
        <ul class="submenu">
          <li><a href="#" data-action="eDelete" data-i18n="eDelete">Delete</a></li>
          <li><a href="#" data-action="eMove"   data-i18n="eMove">Move</a></li>
          <li><a href="#" data-action="eModify" data-i18n="eModify">Modify</a></li>
        </ul>
      </li>

      <li class="menu-item">
        <div class="menu-titulo" data-i18n="simulateMenu">Simulate</div>
        <ul class="submenu">
          <li><a href="#" data-action="sInit"     data-i18n="sInit">Init</a></li>
          <li><a href="#" data-action="sStep"     data-i18n="sStep">Step 's'</a></li>
          <li><a href="#" data-action="sStop"     data-i18n="sStop">Stop</a></li>
          <li><a href="#" data-action="sContinue" data-i18n="sContinue">Continue</a></li>
          <li><a href="#" data-action="sReset" data-i18n="sReset">Reset</a></li>
        </ul>
      </li>

    </ul>
  </nav>

  <canvas id="canvas" class="canvas"></canvas>

  <dialog id="textPrompt">
    <form method="dialog">
      <p id="messageInput">Texto:</p>
      <input type="text" name="answer" id="textInput" placeholder="Text...">
      <div style="margin-top: 16px;">
        <button id="confirmBtn" value="default">Aceptar</button>
        <button id="cancelBtn" value="cancel" formnovalidate>Cancelar</button>
      </div>
    </form>
  </dialog>

  <dialog id="aboutWindow">
    <div>
    <h2>Picuino Pneumatic Simulator</h2>
    <p><strong>Copyright © 2025 Carlos Félix Pardo Martín.</strong></p>
    <p><strong>Email:</strong> <span style="unicode-bidi:bidi-override; direction: rtl;">moc.oniu<span style="display:none">n</span>cip&#64;sol<span style="display:none">novale</span>rac<span></p>
    <p><strong>Original:</strong> <a href="https://www.picuino.com/neumatic/index.html" target="_blank">Pneumatic simulator original web page</a>.</p>
    <p><strong>Tutorial:</strong> <a href="https://www.picuino.com/es/mecan-neumatic-index.html" target="_blank">Pneumatics tutorial</a>.</p>
    <p><strong>GitHub:</strong> <a href="https://github.com/picuino/neumatic/" target="_blank">Pneumatic Simulator source code</a>.</p>
    <p>
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.</p>
    <p>
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.</p>
    <p>
    You should have received a copy of the GNU General Public License
    along with this program. If not, see
    <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank">
    www.gnu.org/licenses/gpl-3.0.html</a>.</p>
    <button id="closeBtn" data-i18n="closeBtn">Close window</button>
    </div>
  </dialog>


<script>

/*
   Picuino Pneumatic Simulator.

   Copyright © 2025 Carlos Félix Pardo Martín.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program. If not, see <https://www.gnu.org/licenses/>.
*/

/* Global constants and variables */
const programVersion = '2.0';
const canvas = document.getElementById('canvas');
const grid = 10;
const lineWidth = 2;
const nearDist = 5;
const selectedColor = '#44f';
const defaultColor = '#000';
const textFont = '14px sans-serif';
const canvasScale = 2;
const airPressure = 1; // bar
const compressorPressure = 8; // bar
const conductanceBase = 2000;
const minTimestamp = parseInt('1900000000', 16);

let drawMode = null;
let componentType = null;
let componentMove = null;
let componentEdit = null;
let editPipe = null;
let pipeMove = null;
let initPos = null;
let endPos = null;
let running = false;
let globalLang = null;
let mousePosition = null;
let stepTime = null;
let simulationActive = false;
let activateValvesTouchingBody = true;

/*************************************************************************/

const translations = {

  en: {
    title: 'Pneumatic Simulator - Picuino',
    closeBtn: 'Close window',
    fileMenu: 'File',
    fSwap: 'Swap Screen',
    fNew: 'New Schematic',
    fOpen: 'Open Schematic',
    fSave: 'Save Schematic',
    fSaveStudent: 'Student',
    fSaveTeacher: 'Teacher',
    fSavePNG: 'Save Image',
    fAbout: 'About...',
    examplesMenu: 'Examples',
    singleMenu: 'Single',
    doubleMenu: 'Double',
    multipleMenu: 'Multiple',
    drawMenu: 'Draw',
    valvesMenu: 'Valves',
    cValve22m: 'Valve 2/2 manual',
    cValve32m: 'Valve 3/2 manual',
    cValve32r: 'Valve 3/2 with roller',
    cRoller: 'Roller of valve',
    cValve52m: 'Valve 5/2 manual',
    cValve52p: 'Valve 5/2 pneu. pilot',
    auxValvesMenu: 'Aux. valves',
    cValveNret: 'Non-return valve',
    cValveFlow: 'Choke valve',
    cValveOr: 'OR valve',
    cValveAnd: 'AND valve',
    cylinderMenu: 'Cylinders',
    cCylinder1: 'Single-acting',
    cCylinder2: 'Double-acting',
    cPress: 'Compressor',
    cPipe: 'Pipe',
    cEscape: 'Escape',
    cText: 'Text',
    editMenu: 'Edit',
    eDelete: 'Delete',
    eMove: 'Move',
    eModify: 'Modify',
    simulateMenu: 'Simulate',
    sInit: 'Init',
    sStep: "Step 's'",
    sStop: 'Stop',
    sContinue: 'Continue',
    sReset: 'Reset',
  },

  es: {
    title: 'Simulador Neumático - Picuino',
    closeBtn: 'Cerrar ventana',
    fileMenu: 'Archivo',
    fSwap: 'Cambiar pantalla',
    fNew: 'Nuevo Esquema',
    fOpen: 'Abrir Esquema',
    fSave: 'Guardar Esquema',
    fSaveStudent: 'Alumno',
    fSaveTeacher: 'Profesor',
    fSavePNG: 'Guardar Imagen',
    fAbout: 'Sobre...',
    examplesMenu: 'Ejemplos',
    singleMenu: 'Simple',
    doubleMenu: 'Doble',
    multipleMenu: 'Múltiple',
    drawMenu: 'Dibujar',
    valvesMenu: 'Válvulas',
    cValve22m: 'Válvula 2/2 manual',
    cValve32m: 'Válvula 3/2 manual',
    cValve32r: 'Válvula 3/2 con rodillo',
    cRoller: 'Rodillo de válvula',
    cValve52m: 'Válvula 5/2 manual',
    cValve52p: 'Válvula 5/2 pilotada neum.',
    auxValvesMenu: 'Válvulas aux.',
    cValveNret: 'Válvula antirretorno',
    cValveFlow: 'Válvula estranguladora',
    cValveOr: 'Válvula selectora (OR)',
    cValveAnd: 'Válvula simultaneidad (AND)',
    cylinderMenu: 'Cilindros',
    cCylinder1: 'Simple efecto',
    cCylinder2: 'Doble efecto',
    cPress: 'Compresor',
    cPipe: 'Tubería',
    cEscape: 'Escape',
    cText: 'Texto',
    editMenu: 'Editar',
    eDelete: 'Borrar',
    eMove: 'Mover',
    eModify: 'Modificar',
    simulateMenu: 'Simular',
    sInit: 'Iniciar',
    sStep: "Paso 's'",
    sStop: 'Detener',
    sContinue: 'Continuar',
    sReset: 'Reiniciar',
  }
}


/*************************************************************************/

/* Menús y submenus */
document.addEventListener("click", (e) => {
  const trigger = e.target.closest(".menu-titulo, .has-submenu > a");

  // Click fuera del menú ? cerrar todo
  if (!trigger) {
    document.querySelectorAll(".submenu").forEach(sm =>
      sm.classList.remove("activo")
    );
    return;
  }

  e.preventDefault();
  e.stopPropagation();

  const submenu = trigger.nextElementSibling;
  if (!submenu || !submenu.classList.contains("submenu")) return;

  // Cerrar submenús hermanos
  const siblings = trigger.parentElement.parentElement
    .querySelectorAll(":scope > li > .submenu");

  siblings.forEach(sm => {
    if (sm !== submenu) sm.classList.remove("activo");
  });

  submenu.classList.toggle("activo");
});


/* menu actions */
document.addEventListener("click", (e) => {
  const item = e.target.closest("a[data-action]");
  if (!item) return;

  e.preventDefault();
  e.stopPropagation();

  const action = item.dataset.action;

  const actions = {
    fSwap: () => { swapScreen() },
    fNew: () => { resetEditor() },
    fOpen: () => { openSchema(); },
    fSaveStudent: () => { saveSchema('student'); },
    fSaveTeacher: () => { saveSchema('teacher'); },
    fSavePNG: () => { savePNG(); },
    enLang: () => { enLang(); },
    esLang: () => { esLang(); },
    fAbout: () => { aboutWindowShow(); },

    cPipe: () =>      { simulationStop(); drawMode='component'; componentType='Pipe'; },
    cPress: () =>     { simulationStop(); drawMode='component'; componentType='Compressor'; },
    cEscape: () =>    { simulationStop(); drawMode='component'; componentType='Escape'; },
    cText: () =>      { simulationStop(); drawMode='component'; componentType='Text'; },
    cValve22m: () =>  { simulationStop(); drawMode='component'; componentType='Valve22m'; },
    cValve32m: () =>  { simulationStop(); drawMode='component'; componentType='Valve32m'; },
    cValve32r: () =>  { simulationStop(); drawMode='component'; componentType='Valve32r'; },
    cRoller: () =>    { simulationStop(); drawMode='component'; componentType='Roller'; },
    cValve52m: () =>  { simulationStop(); drawMode='component'; componentType='Valve52m'; },
    cValve52p: () =>  { simulationStop(); drawMode='component'; componentType='Valve52p'; },
    cValveOr: () =>   { simulationStop(); drawMode='component'; componentType='ValveOr'; },
    cValveAnd: () =>  { simulationStop(); drawMode='component'; componentType='ValveAnd'; },
    cValveNret: () => { simulationStop(); drawMode='component'; componentType='ValveNret'; },
    cValveFlow: () => { simulationStop(); drawMode='component'; componentType='ValveFlow'; },
    cCylinder1: () => { simulationStop(); drawMode='component'; componentType='Cylinder1'; },
    cCylinder2: () => { simulationStop(); drawMode='component'; componentType='Cylinder2'; },

    eDelete: () => { simulationStop(); drawMode='Delete'; },
    eMove: () => { simulationStop(); drawMode='Move'; },
    eModify: () => { simulationStop(); drawMode='Modify'; },

    sInit: () => { simulationInit(); },
    sStep: () => { simulationStep(); },
    sStop: () => { simulationStop(); },
    sContinue: () => { simulationContinue(); },
    sReset: () => { simulationReset(); },
  };

  actions[action]?.();

  // Cerrar todos los menús tras la acción
  document.querySelectorAll(".submenu").forEach(sm =>
    sm.classList.remove("activo")
  );
});


/*************************************************************************/
class ComponentBase {
  constructor(pos){
    this.timestamp = this.timestamp();
    this.x = snap(pos.x);
    this.y = snap(pos.y);
    this.type = 'ComponentBase';
    this.selected = false;
    this.grid = grid;
    this.options = {};
  }

  move(x, y) {
    this.x = snap(x, this.grid);
    this.y = snap(y, this.grid);
  }

  timestamp() {
    const seconds = Math.floor(Date.now()*0.1);
    return seconds.toString(16).toUpperCase();
  }

  near() {
    return null;
  }

  nearPos(a, b) {
    if ((Math.abs(a.x - b.x) <= nearDist) && (Math.abs(a.y - b.y) <= nearDist)) {
       return true;
    }
    else {
      return null;
    }
  }

  nearRect(a_x, a_y, b_x, b_y, pos) {
    const minX = Math.min(a_x, b_x);
    const maxX = Math.max(a_x, b_x);
    const minY = Math.min(a_y, b_y);
    const maxY = Math.max(a_y, b_y);
    if (pos.x >= minX && pos.x <= maxX &&
        pos.y >= minY && pos.y <= maxY) {
      return true;
    }
    return false;
  }

  draw(ctx){
  }

  drawPort(ctx, pos_x, pos_y, size_x, size_y, color=defaultColor) {
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.fillRect(pos_x-lineWidth, pos_y-lineWidth, lineWidth*2, lineWidth*2);
    ctx.beginPath();
    ctx.moveTo(pos_x, pos_y);
    ctx.lineTo(pos_x+size_x, pos_y+size_y);
    ctx.stroke();
  }

  drawArrow(ctx, init_x, init_y, end_x, end_y, color=defaultColor) {
    const arrowHeadSize = 8;
    const arrowAngle = Math.PI/10;
    const angle = Math.atan2(end_y - init_y, end_x - init_x);

    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;

    // Body line
    ctx.beginPath();
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(end_x - arrowHeadSize * Math.cos(angle),
               end_y - arrowHeadSize * Math.sin(angle));
    ctx.stroke();

    // Arrow
    ctx.beginPath();
    ctx.moveTo(end_x, end_y);
    ctx.lineTo(end_x - arrowHeadSize * Math.cos(angle - arrowAngle),
               end_y - arrowHeadSize * Math.sin(angle - arrowAngle));
    ctx.lineTo(end_x - arrowHeadSize * Math.cos(angle + arrowAngle),
               end_y - arrowHeadSize * Math.sin(angle + arrowAngle));
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  drawTap(ctx, init_x, init_y, end_x, end_y, color=defaultColor) {
    const tapSize = 5;
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(end_x, end_y);
    ctx.moveTo(end_x-tapSize, end_y);
    ctx.lineTo(end_x+tapSize, end_y);
    ctx.stroke();
  }

  drawRectangle(ctx, init_x, init_y, end_x, end_y, color=defaultColor) {
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.strokeRect(init_x, init_y, end_x-init_x, end_y-init_y);
    ctx.stroke();
  }

  drawSpring(ctx, init_x, init_y, color=defaultColor) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(init_x+5, init_y-10);
    ctx.lineTo(init_x+10, init_y);
    ctx.lineTo(init_x+15, init_y-10);
    ctx.lineTo(init_x+20, init_y);
    ctx.stroke();
  }

  drawPushButton(ctx, init_x, init_y, color=defaultColor) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.moveTo(init_x, init_y);
    ctx.lineTo(init_x-20, init_y);
    ctx.lineTo(init_x-20, init_y-10);
    ctx.lineTo(init_x-13, init_y-10);
    ctx.lineTo(init_x-10, init_y-5);
    ctx.lineTo(init_x-7, init_y-10);
    ctx.lineTo(init_x, init_y-10);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(init_x-20, init_y+5);
    ctx.lineTo(init_x-20, init_y-15);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(init_x-10, init_y-15);
    ctx.lineTo(init_x-10, init_y-10);
    ctx.stroke();
  }

  drawPushRoller(ctx, init_x, init_y, color=defaultColor) {
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(init_x, init_y-4);
    ctx.lineTo(init_x-12, init_y-4);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(init_x, init_y+4);
    ctx.lineTo(init_x-12, init_y+4);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(init_x-16, init_y, 6, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(init_x-16, init_y, 1, 0, Math.PI*2);
    ctx.stroke();
  }

  update(ctx, engine, dt) {}

  reset () {}

  colorPressure(pressure, bg = 0) {
    let cp = Math.round(255 * ((pressure - airPressure) / (compressorPressure - airPressure)));
    if (bg === 0) {
      return 'rgb(' + cp + ',' + 0 + ',' + 0 + ')';
    }
    else {
      cp = 255 - cp;
      return 'rgb(' + 255 + ',' + cp + ',' + cp + ')';
    }
  }

  computeFlow(node1, node2, conductance, dt) {
    const m1 = node1.mass;
    const m2 = node2.mass;
    const volume1 = node1.volume;
    const volume2 = node2.volume;

    function flow(m1, m2) {
      const dp = m1 / volume1 - m2 / volume2;
      return conductance * Math.sign(dp) * Math.sqrt(Math.abs(dp));
    }

    const q1 = flow(m1, m2);
    const k1_m = dt * q1;

    const q2 = flow(m1 - 0.5*k1_m, m2 + 0.5*k1_m);
    const k2_m = dt * q2;

    const q3 = flow(m1 - 0.5*k2_m, m2 + 0.5*k2_m);
    const k3_m = dt * q3;

    const q4 = flow(m1 - k3_m, m2 + k3_m);
    const k4_m = dt * q4;

    const dm = (k1_m + 2*k2_m + 2*k3_m + k4_m)/6;

    node1.mass -= dm;
    node2.mass += dm;

    node1.pressure = node1.mass / node1.volume;
    node2.pressure = node2.mass / node2.volume;
  }

  serialize() {
    return {type:this.type, stamp:this.timestamp, x:this.x, y:this.y, options:this.options};
  }
}


class Text extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.x = snap(pos.x, grid*0.5);
    this.y = snap(pos.y, grid*0.5);
    this.type = 'Text';
    this.grid = grid*0.5;
    this.color = defaultColor;
    this.options = {
      text: 'Text',
    };
  }

  vias() {
    return [];
  }

  near(pos) {
    return this.nearRect(this.x+5, this.y-10, this.x+35, this.y+5, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    ctx.font = textFont;
    ctx.fillStyle = this.color;
    ctx.fillText(this.options.text, this.x+5, this.y+5);
  }
}


class Pipe extends ComponentBase {
  constructor(posInit, posEnd) {
    super(posInit);
    this.type = 'Pipe';
    this.init = {x: snap(posInit.x), y: snap(posInit.y)};
    this.end = {x: snap(posEnd.x), y: snap(posEnd.y)};
    this.conductance = conductanceBase;
    this.color = defaultColor;
  }

  vias() {
    const via1 = this.init;
    const via2 = this.end;
    return [via1, via2];
  }

  reset() {
    this.color = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    this.computeFlow(node1, node2, this.conductance, dt);
    this.color = this.colorPressure(0.5*(node1.pressure + node2.pressure));
  }

  moveInit(pos) {
    this.init = {x: snap(pos.x), y: snap(pos.y)};
  }

  moveEnd(pos) {
    this.end = {x: snap(pos.x), y: snap(pos.y)};
  }

  near(pos) {
    if (this.nearPos(this.init, pos)) {
      return 'init';
    }
    if (this.nearPos(this.end, pos)) {
      return 'end';
    }
    return null;
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.fillRect(this.init.x-lineWidth, this.init.y-lineWidth, lineWidth*2, lineWidth*2);
    ctx.fillRect(this.end.x-lineWidth, this.end.y-lineWidth, lineWidth*2, lineWidth*2);
    ctx.moveTo(this.init.x, this.init.y);
    ctx.lineTo(this.end.x, this.end.y);
    ctx.stroke();
  };

  serialize(){
    return {type:this.type, stamp:this.timestamp, init:this.init, end:this.end};
  }
}


class Compressor extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Compressor';
    this.pressure = compressorPressure;
    this.color = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    return [via1];
  }

  reset() {
    this.color = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1] = this.vias()
    const node = engine.findNode(via1);
    node.pressure = this.pressure;
    node.mass = node.pressure * node.volume;
    this.color = '#f00';
  }

  near(pos) {
    return this.nearRect(this.x-8, this.y+5, this.x+8, this.y+25, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, 10, this.color);
    ctx.beginPath();
    ctx.arc(this.x,this.y+10+7,7,0,Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x,this.y+10+7,2,0,Math.PI*2);
    ctx.stroke();
  }
}


class ValveNret extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveNret';
    this.conductance = conductanceBase;
    this.minPressure = 0.02; // bar
    this.active = false;
    this.options = {
      flipped: false,
    };
    this.color1 = defaultColor;
    this.color2 = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    return [via1, via2];
  }

  reset () {
    this.active = false;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    let dpress = 0;
    if (this.options.flipped) {
      dpress = node2.pressure - node1.pressure;
    }
    else {
      dpress = node1.pressure - node2.pressure;
    }
    if (dpress > this.minPressure) {
      this.computeFlow(node1, node2, this.conductance, dt);
      this.active = true;
    }
    else {
      this.active = false;
    }
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
  }

  flip() {
    if (this.options.flipped === true) {
      this.options.flipped = false;
    }
    else {
      this.options.flipped = true;
    }
  }

  near(pos) {
    return this.nearRect(this.x-10, this.y-40, this.x+10, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x, this.y-50, 0, 10, this.color2);
    if (this.options.flipped) {
      this.drawValveNretFlipped(ctx);
    }
    else {
      this.drawValveNret(ctx);
    }
  }

  drawValveNretFlipped(ctx) {
    ctx.strokeStyle = this.color2;
    ctx.beginPath();
    ctx.lineTo(this.x, this.y-40);
    ctx.lineTo(this.x, this.y-35);
    ctx.lineTo(this.x-10, this.y-25);
    ctx.lineTo(this.x, this.y-35);
    ctx.lineTo(this.x+10, this.y-25);
    ctx.stroke();

    ctx.beginPath();
    if (this.active === false) {
      ctx.strokeStyle = this.color1;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y-18);
      ctx.lineTo(this.x, this.y-10);
      ctx.stroke();

      ctx.strokeStyle = defaultColor;
      ctx.beginPath();
      ctx.arc(this.x,this.y-24, 6, 0, Math.PI*2);
      ctx.stroke();
    }
    else {
      ctx.strokeStyle = this.color1;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y-14);
      ctx.lineTo(this.x, this.y-10);
      ctx.stroke();

      ctx.strokeStyle = defaultColor;
      ctx.beginPath();
      ctx.arc(this.x,this.y-20, 6, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  drawValveNret(ctx) {
    ctx.strokeStyle = this.color1;
    ctx.beginPath();
    ctx.lineTo(this.x, this.y-10);
    ctx.lineTo(this.x, this.y-15);
    ctx.lineTo(this.x-10, this.y-25);
    ctx.lineTo(this.x, this.y-15);
    ctx.lineTo(this.x+10, this.y-25);
    ctx.stroke();

    ctx.beginPath();
    if (this.active === false) {
      ctx.strokeStyle = this.color2;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y-32);
      ctx.lineTo(this.x, this.y-40);
      ctx.stroke();
      
      ctx.strokeStyle = defaultColor;
      ctx.beginPath();
      ctx.arc(this.x,this.y-26, 6, 0, Math.PI*2);
      ctx.stroke();
    }
    else {
      ctx.strokeStyle = this.color2;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y-36);
      ctx.lineTo(this.x, this.y-40);
      ctx.stroke();
      
      ctx.strokeStyle = defaultColor;
      ctx.beginPath();
      ctx.arc(this.x,this.y-30, 6, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.stroke();
  }
}


class ValveFlow extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveFlow';
    this.options = {
      conductance: 100,
    }
    this.color = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    return [via1, via2];
  }

  reset() {
    this.color = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    if (this.options.conductance > 500) this.options.conductance = 500;
    if (this.options.conductance < 10) this.options.conductance = 10;
    this.computeFlow(node1, node2, this.options.conductance, dt);
    this.color = this.colorPressure(0.5*(node1.pressure + node2.pressure));
  }

  near(pos) {
    return this.nearRect(this.x-15, this.y-40, this.x+15, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color);
    this.drawPort(ctx, this.x, this.y-50, 0, 10, this.color);
    this.drawValveFlow(ctx);
  }

  drawValveFlow(ctx) {
    ctx.strokeStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.x, this.y-10);
    ctx.lineTo(this.x, this.y-40);
    ctx.stroke();

    ctx.strokeStyle = defaultColor;
    ctx.fillStyle = defaultColor;
    ctx.beginPath();
    ctx.arc(this.x-25,this.y-25, 22, -Math.PI*0.16, Math.PI*0.16);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x+25,this.y-25, 22, Math.PI*0.84, Math.PI*1.16);
    ctx.stroke();
    this.drawArrow(ctx, this.x-18, this.y-15, this.x+18, this.y-35);
  }
}


class ValveOr extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveOr';
    this.shift = 14;
    this.maxShift = 28;
    this.conductance = conductanceBase;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
  }

  vias() {
    const in1 = {x:this.x-40, y:this.y+30};
    const in2 = {x:this.x+40, y:this.y+30};
    const out = {x:this.x, y:this.y};
    return [in1, in2, out];
  }

  reset () {
    this.shift = this.maxShift*0.5;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);

    if (this.shift !== this.maxShift) {
      this.computeFlow(node2, node3, this.conductance, dt);
    }
    if (this.shift !== 0) {
      this.computeFlow(node1, node3, this.conductance, dt);
    }

    if (this.shift !== this.maxShift && node1.pressure > node2.pressure + 0.1) {
      this.shift = this.maxShift;
    }
    if (this.shift !== 0 && node2.pressure > node1.pressure + 0.1) {
      this.shift = 0;
    }
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
    this.color3 = this.colorPressure(node3.pressure);
  }

  near(pos) {
    return this.nearRect(this.x-30, this.y+15, this.x+30, this.y+45, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x-40, this.y+30, 12, 0, this.color1);
    this.drawPort(ctx, this.x+40, this.y+30, -12, 0, this.color2);
    this.drawPort(ctx, this.x, this.y, 0, 17, this.color3);
    this.drawValveOr(ctx);
    this.drawMovement(ctx);
  }

  drawValveOr(ctx) {
    ctx.strokeStyle = this.color1;
    ctx.beginPath();
    ctx.moveTo(this.x-18, this.y+20);
    ctx.lineTo(this.x-28, this.y+30);
    ctx.lineTo(this.x-18, this.y+40);
    ctx.stroke();

    ctx.strokeStyle = this.color2;
    ctx.beginPath();
    ctx.moveTo(this.x+18, this.y+20);
    ctx.lineTo(this.x+28, this.y+30);
    ctx.lineTo(this.x+18, this.y+40);
    ctx.stroke();

    this.drawRectangle(ctx, this.x-30, this.y+17, this.x+30, this.y+43);
  }

  drawMovement(ctx) {
    const posX = this.x + this.shift;
    ctx.strokeStyle = defaultColor;
    ctx.beginPath();
    ctx.arc(posX-14,this.y+30, 8, 0, Math.PI*2);
    ctx.stroke();
  }
}


class ValveAnd extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'ValveAnd';
    this.shift = 4;
    this.maxShift = 8;
    this.conductance = conductanceBase;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
    this.color1w = '#fff';
    this.color2w = '#fff';
    this.color3w = '#fff';
  }

  vias() {
    const in1 = {x:this.x-40, y:this.y+30};
    const in2 = {x:this.x+40, y:this.y+30};
    const out = {x:this.x, y:this.y};
    return [in1, in2, out];
  }

  reset () {
    this.shift = maxShift * 0.5;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
    this.color1w = '#fff';
    this.color2w = '#fff';
    this.color3w = '#fff';
  }

  update(ctx, engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);

    if (this.shift !== this.maxShift) {
      this.computeFlow(node1, node3, this.conductance, dt);
    }
    if (this.shift !== 0) {
      this.computeFlow(node2, node3, this.conductance, dt);
    }

    if (node1.pressure > node2.pressure + 0.1) {
      this.shift = this.maxShift;
    }
    if (node2.pressure > node1.pressure + 0.1) {
      this.shift = 0;
    }
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
    this.color3 = this.colorPressure(node3.pressure);
    this.color1w = this.colorPressure(node1.pressure, 1);
    this.color2w = this.colorPressure(node2.pressure, 1);
    this.color3w = this.colorPressure(node3.pressure, 1);
  }

  near(pos) {
    return this.nearRect(this.x-30, this.y+15, this.x+30, this.y+45, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x-40, this.y+30, 10, 0, this.color1);
    this.drawPort(ctx, this.x+40, this.y+30, -10, 0, this.color2);
    this.drawPort(ctx, this.x, this.y, 0, 17, this.color3);
    this.drawPressures(ctx);
    this.drawValveAnd(ctx);
    this.drawMovement(ctx);
  }

  drawPressures(ctx) {
    ctx.fillStyle = this.color1w;
    ctx.fillRect(this.x-30, this.y+17, 14, 26);
    ctx.fillStyle = this.color2w;
    ctx.fillRect(this.x+16, this.y+17, 14, 26);
    ctx.fillStyle = this.color3w;
    ctx.fillRect(this.x-15, this.y+17, 30, 26);
  }

  drawValveAnd(ctx) {
    this.drawRectangle(ctx, this.x-30, this.y+17, this.x+30, this.y+43);

    ctx.beginPath();
    ctx.moveTo(this.x-15, this.y+17);
    ctx.lineTo(this.x-15, this.y+26);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x-15, this.y+43);
    ctx.lineTo(this.x-15, this.y+34);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x+15, this.y+17);
    ctx.lineTo(this.x+15, this.y+26);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x+15, this.y+43);
    ctx.lineTo(this.x+15, this.y+34);
    ctx.stroke();
  }

  drawMovement(ctx) {
    const posX = this.x + this.shift;
    ctx.beginPath();
    ctx.moveTo(posX-25, this.y+21);
    ctx.lineTo(posX-25, this.y+39);
    ctx.moveTo(posX-25, this.y+30);
    ctx.lineTo(posX+17, this.y+30);
    ctx.moveTo(posX+17, this.y+21);
    ctx.lineTo(posX+17, this.y+39);
    ctx.stroke();
  }
}


class Escape extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Escape';
    this.pressure = airPressure;
    this.color = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    return [via1];
  }


  update(ctx, engine, dt) {
    const [via1] = this.vias()
    const node = engine.findNode(via1);
    node.pressure = this.pressure;
    node.mass = node.pressure * node.volume;
  }

  near(pos) {
    return this.nearRect(this.x-5, this.y, this.x+5, this.y+18, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, 10, this.color);
    ctx.beginPath();
    ctx.moveTo(this.x,   this.y+10);
    ctx.lineTo(this.x-6, this.y+10);
    ctx.lineTo(this.x,   this.y+20);
    ctx.lineTo(this.x+6, this.y+10);
    ctx.lineTo(this.x,   this.y+10);
    ctx.stroke();
  }
}


class Cylinder1 extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Cylinder1';
    this.shift = 0;
    this.maxShift = 90;
    this.color = '#000';
    this.pressure1 = airPressure; // bar
    this.n = 0;
    this.conductance = conductanceBase;
    this.position = {min:0, max:0.20, actual:0};
    this.volumeMin = 12; // cm3
    this.area = 12; // cm3
    this.springForce = 50; // kgf/m
    this.springForceMin = 2; // kgf
    this.frictionForce = 0.5; // kgf
    this.frictionStatic = 0.8; // kgf
    this.pistonMass = 0.5; // kg
    this.mass1 = 0;
    this.speed = 0; // cm/s
    this.color1 = defaultColor;
    this.color1w = '#fff';
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    return [via1];
  }

  reset () {
    this.position.actual = this.position.min;
    this.pressure1 = airPressure;
    this.mass1 = 0;
    this.shift = 0;
    this.color1 = defaultColor;
    this.color1w = '#fff';
  }

  update(ctx, engine, dt) {
    const [via1] = this.vias();
    const node1 = engine.findNode(via1);

    let volume1 = 100*this.position.actual * this.area + this.volumeMin;
    if (this.mass1 === 0) this.mass1 = this.pressure1 * volume1;

    // Compute node1 flow
    const m1 = node1.mass;
    const m2 = this.mass1;
    const n1_vol = node1.volume;

    let dp = m1 / n1_vol - m2 / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    const k1_m = dt * dp * this.conductance;

    dp = (m1 - 0.5*k1_m) / n1_vol - (m2 + 0.5*k1_m) / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    const k2_m = dt * dp * this.conductance;

    dp = (m1 - 0.5*k2_m) / n1_vol - (m2 + 0.5*k2_m) / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    const k3_m = dt * dp * this.conductance;

    dp = (m1 - k3_m) / n1_vol - (m2 + k3_m) / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    const k4_m = dt * dp * this.conductance;

    const dm = (k1_m + 2*k2_m + 2*k3_m + k4_m)/6;

    node1.mass -= dm;
    this.mass1 += dm;

    node1.pressure = node1.mass / n1_vol;
    this.pressure1 = this.mass1 / volume1;


    // Compute piston movement     pressure
    for(let i = 0; i < 10; i++) {
      volume1 = 100*this.position.actual * this.area + this.volumeMin;
      this.pressure1 = this.mass1 / volume1;
      let forcePiston = (this.pressure1 - airPressure) * this.area; // kgf
      const forceSpring = this.springForceMin + this.position.actual*this.springForce;
      let netForce = forcePiston - forceSpring;

      if (this.speed === 0) {
        if (Math.abs(netForce) > this.frictionStatic)
          netForce -= this.frictionForce*Math.sign(netForce);
        else
          netForce = 0;
        this.speed = 0.1 * dt * netForce * 9.8 / this.pistonMass;
      }
      else {
        netForce -= this.frictionForce*Math.sign(this.speed);
        const dspeed = 0.1 * dt * netForce * 9.8 / this.pistonMass;
        if (Math.sign(dspeed) !== Math.sign(this.speed) &&
          Math.abs(dspeed) > Math.abs(this.speed)) {
          this.speed = 0;
        }
        else {
          this.speed += dspeed;
        }
      }
      this.position.actual += 0.1*dt * this.speed;
    }

    // Stop at begining and end. Shift piston image
    if (this.position.actual < this.position.min) {
      this.position.actual = this.position.min;
      this.speed = 0;
    }
    if (this.position.actual > this.position.max) {
      this.position.actual = this.position.max;
      this.speed = 0;
    }
    this.shift = this.maxShift * (this.position.actual-this.position.min)/
                 (this.position.max - this.position.min);

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color1w = this.colorPressure(node1.pressure, 1);
  }

  near(pos) {
    return this.nearRect(this.x-5, this.y-40, this.x+95, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPressure(ctx, this.x-5, this.y-40);
    this.drawRectangle(ctx, this.x-5, this.y-40, this.x+115, this.y-10);
    this.drawPiston(ctx, this.shift);
  }

  drawPressure(ctx, posX, posY) {
    ctx.fillStyle = this.color1w;
    ctx.fillRect(posX, posY, 10 + this.shift, 30);
  }

  drawPiston(ctx, shift) {
    let posX = this.x + shift;
    this.drawRectangle(ctx, posX+5, this.y-10, posX+15, this.y-40);
    this.drawRectangle(ctx, posX+15, this.y-20, posX+125, this.y-30);
    this.drawRectangle(ctx, posX+125, this.y-15, posX+145, this.y-35);
    this.drawSpring(ctx, posX+15, this.y-13, this.x+115);
  }

  drawSpring(ctx, initX, initY, endX) {
    const step = (endX-initX)/6;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.lineJoin = 'round';
    ctx.moveTo(initX, initY);
    ctx.lineTo(initX+step, initY-24);
    ctx.lineTo(initX+step*2, initY+0);
    ctx.lineTo(initX+step*3, initY-24);
    ctx.lineTo(initX+step*4, initY+0);
    ctx.lineTo(initX+step*5, initY-24);
    ctx.lineTo(initX+step*6, initY+0);
    ctx.stroke();
    ctx.lineJoin = 'miter';
  }
}


class Cylinder2 extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Cylinder2';
    this.shift = 0;
    this.maxShift = 90;
    this.color = '#000';
    this.conductance = conductanceBase;
    this.pressure1 = 1; // bar
    this.pressure2 = 1; // bar
    this.volumeMin = 12;
    this.area1 = 12; // cm3
    this.area2 = 9; // cm3
    this.mass1 = 0;
    this.mass2 = 0;
    this.areaRod = this.area1 - this.area2;
    this.frictionForce = 1; // kgf
    this.frictionStatic = 2; //kgf
    this.pistonMass = 0.5; // kg
    this.position = {min:0, max:0.20, actual:0};
    this.speed = 0; // cm/s
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color1w = '#fff';
    this.color2w = '#fff';
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x+110, y:this.y};
    return [via1, via2];
  }

  reset () {
    this.position.actual = this.position.min;
    this.pressure1 = airPressure;
    this.pressure2 = airPressure;
    this.mass1 = 0;
    this.mass2 = 0;
    this.shift = 0;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color1w = '#fff';
    this.color2w = '#fff';
  }

  update(ctx, engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);

    // Simulation
    let volume1 = 100*this.position.actual * this.area1 + this.volumeMin;  // cm3
    let volume2 = 100*(this.position.max - this.position.actual) * this.area2 + this.volumeMin; //cm3
    if (this.mass1 === 0) this.mass1 = this.pressure1 * volume1;
    if (this.mass2 === 0) this.mass2 = this.pressure2 * volume2;

    // Compute node1 flow
    // Compute node1 mass flux
    const m_n1 = node1.mass;
    const m_p1 = this.mass1;
    const n1_vol = node1.volume;

    let dp = m_n1 / n1_vol - m_p1 / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    let k1_m = dt * dp * this.conductance;

    dp = (m_n1 - 0.5*k1_m) / n1_vol - (m_p1 + 0.5*k1_m) / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    let k2_m = dt * dp * this.conductance;

    dp = (m_n1 - 0.5*k2_m) / n1_vol - (m_p1 + 0.5*k2_m) / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    let k3_m = dt * dp * this.conductance;

    dp = (m_n1 - k3_m) / n1_vol - (m_p1 + k3_m) / volume1;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    let k4_m = dt * dp * this.conductance;

    let dm = (k1_m + 2*k2_m + 2*k3_m + k4_m)/6;

    node1.mass -= dm;
    this.mass1 += dm;

    node1.pressure = node1.mass / n1_vol;
    this.pressure1 = this.mass1 / volume1;

    // Compute node2 flow
    const m_n2 = node2.mass;
    const m_p2 = this.mass2;
    const n2_vol = node2.volume;

    dp = m_n2 / n2_vol - m_p2 / volume2;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    k1_m = dt * dp * this.conductance;

    dp = (m_n2 - 0.5*k1_m) / n2_vol - (m_p2 + 0.5*k1_m) / volume2;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    k2_m = dt * dp * this.conductance;

    dp = (m_n2 - 0.5*k2_m) / n2_vol - (m_p2 + 0.5*k2_m) / volume2;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    k3_m = dt * dp * this.conductance;

    dp = (m_n2 - k3_m) / n2_vol - (m_p2 + k3_m) / volume2;
    dp = Math.sign(dp) * Math.sqrt(Math.abs(dp))
    k4_m = dt * dp * this.conductance;

    dm = (k1_m + 2*k2_m + 2*k3_m + k4_m)/6;

    node2.mass -= dm;
    this.mass2 += dm;

    node2.pressure = node2.mass / n2_vol;
    this.pressure2 = this.mass2 / volume2;

    // Compute piston movement
    for(let i = 0; i < 10; i++) {
      let force1 = this.pressure1 * this.area1; // kgf
      let force2 = this.pressure2 * this.area2 + airPressure * this.areaRod; // kgf
      let netForce = force1 - force2;

      if (this.speed === 0) {
        if (Math.abs(netForce) > this.frictionStatic)
          netForce -= this.frictionForce*Math.sign(netForce);
        else
          netForce = 0;
        this.speed += 0.1 * dt * netForce * 9.8 / this.pistonMass;
      }
      else {
        netForce -= this.frictionForce*Math.sign(this.speed);
        const dspeed = 0.1 * dt * netForce * 9.8 / this.pistonMass;
        if (Math.sign(dspeed) !== Math.sign(this.speed) &&
          Math.abs(dspeed) > Math.abs(this.speed)) {
          this.speed = 0;
        }
        else {
          this.speed += dspeed;
        }
      }

      this.position.actual += 0.1 * dt * this.speed;
    }

    // Stop at begining and end. Shift piston image
    if (this.position.actual < this.position.min) {
      this.position.actual = this.position.min;
      this.speed = 0;
    }
    if (this.position.actual > this.position.max) {
      this.position.actual = this.position.max;
      this.speed = 0;
    }
    this.shift = this.maxShift * (this.position.actual-this.position.min)/
                 (this.position.max - this.position.min);

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color1 = this.colorPressure(node2.pressure);
    this.color1w = this.colorPressure(node1.pressure, 1);
    this.color2w = this.colorPressure(node2.pressure, 1);
  }


  near(pos) {
    return this.nearRect(this.x-5, this.y-40, this.x+100, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x+110, this.y, 0, -10, this.color2);
    this.drawPressure1(ctx);
    this.drawPressure2(ctx);
    this.drawRectangle(ctx, this.x-5, this.y-10, this.x+115, this.y-40);
    this.drawPiston(ctx, this.shift);
  }

  drawPressure1(ctx) {
    ctx.fillStyle = this.color1w;
    ctx.fillRect(this.x-5, this.y-40, 10 + this.shift, 30);
  }

  drawPressure2(ctx) {
    ctx.fillStyle = this.color2w;
    ctx.fillRect(this.x+15+this.shift, this.y-40, 100-this.shift, 10);
    ctx.fillRect(this.x+15+this.shift, this.y-20, 100-this.shift, 10);
  }

  drawPiston(ctx, shift) {
    let posX = this.x + shift;
    this.drawRectangle(ctx, posX+5, this.y-10, posX+15, this.y-40);
    this.drawRectangle(ctx, posX+15, this.y-20, posX+125, this.y-30);
    this.drawRectangle(ctx, posX+125, this.y-15, posX+145, this.y-35);
  }
}


class Valve22m extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve22m';
    this.shift = {
      min: 0,
      max: 30,
      pos: 0,
      speed: 200,
    }
    this.conductance = conductanceBase;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    return [via1, via2];
  }

  reset () {
    this.shift.pos = this.shift.min;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);

    if (this.shift.pos === this.shift.max) {
      this.computeFlow(node1, node2, this.conductance, dt);
    }

    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
  }

  near(pos) {
    return this.nearRect(this.x-45, this.y-40, this.x+15, this.y-10, pos);
  }

  nearPushButton(pos) {
    if (this.nearRect(this.x-65+this.shift.pos, this.y-35,
                      this.x-45+this.shift.pos, this.y-15, pos))
      return true;
    if (activateValvesTouchingBody)
      return this.near(pos);
    return false;
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x, this.y-50, 0, 10, this.color2);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    if (shift === this.shift.min) {
      this.drawTap(ctx, posX, this.y-10, posX, this.y-20, this.color1);
      this.drawTap(ctx, posX, this.y-40, posX, this.y-30, this.color2);
      this.drawArrow(ctx, posX-30, this.y-10, posX-30, this.y-40+lineWidth);
    }
    else {
      this.drawTap(ctx, posX, this.y-10, posX, this.y-20);
      this.drawTap(ctx, posX, this.y-40, posX, this.y-30);
      this.drawArrow(ctx, posX-30, this.y-10, posX-30, this.y-40+lineWidth, this.color1);
    }

    this.drawRectangle(ctx, posX-45, this.y-10, posX-15, this.y-40);
    this.drawRectangle(ctx, posX-15, this.y-10, posX+15, this.y-40);
    this.drawSpring(ctx, posX+15, this.y-20);
    this.drawPushButton(ctx, posX-45, this.y-20);
  }
}


class Valve32m extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve32m';
    this.shift = {
      min: 0,
      max: 40,
      pos: 0,
      speed: 200,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    const via3 = {x:this.x+20, y:this.y};
    return [via1, via2, via3];
  }

  reset () {
    this.shift.pos = this.shift.min;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    if (this.shift.pos === this.shift.min) {
      this.computeFlow(node2, node3, this.conductance, dt);
    }
    if (this.shift.pos === this.shift.max) {
      this.computeFlow(node1, node2, this.conductance, dt);
    }
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
    this.color3 = this.colorPressure(node3.pressure);
  }

  near(pos) {
    return this.nearRect(this.x-50, this.y-40, this.x+30, this.y-10, pos);
  }

  nearPushButton(pos) {
    if (this.nearRect(this.x-70+this.shift.pos, this.y-35,
                      this.x-50+this.shift.pos, this.y-15, pos))
      return true;
    if (activateValvesTouchingBody)
      return this.near(pos);
    return false;
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x, this.y-50, 0, 10, this.color2);
    this.drawPort(ctx, this.x+20, this.y, 0, -10, this.color3);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    if (shift === this.shift.min) {
      this.drawArrow(ctx, posX, this.y-40, posX+20, this.y-10-lineWidth, this.color2);
      this.drawTap(ctx, posX, this.y-10, posX, this.y-20, this.color1);

      this.drawArrow(ctx, posX-40, this.y-10, posX-40, this.y-40+lineWidth);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    }
    else {
      this.drawArrow(ctx, posX, this.y-40, posX+20, this.y-10-lineWidth);
      this.drawTap(ctx, posX, this.y-10, posX, this.y-20);

      this.drawArrow(ctx, posX-40, this.y-10, posX-40, this.y-40+lineWidth, this.color1);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20, this.color3);
    }

    this.drawRectangle(ctx, posX-10, this.y-10, posX+30, this.y-40);
    this.drawRectangle(ctx, posX-50, this.y-10, posX-10, this.y-40);
    this.drawSpring(ctx, posX+30, this.y-20);
    this.drawPushButton(ctx, posX-50, this.y-20);
  }
}


class Valve32r extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve32r';
    this.shift = {
      min: 0,
      max: 40,
      pos: 0,
      speed: 200,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color = '#000';
    this.options = {
      reference: '1.1',
    }
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x, y:this.y-50};
    const via3 = {x:this.x+20, y:this.y};
    return [via1, via2, via3];
  }

  reset () {
    this.shift.pos = this.shift.min;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2, via3] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    if (this.shift.pos === this.shift.min) {
      this.computeFlow(node2, node3, this.conductance, dt);
    }
    if (this.shift.pos === this.shift.max) {
      this.computeFlow(node1, node2, this.conductance, dt);
    }
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
    this.color3 = this.colorPressure(node3.pressure);
  }

  near(pos) {
    return this.nearRect(this.x-50, this.y-40, this.x+30, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x, this.y-50, 0, 10, this.color2);
    this.drawPort(ctx, this.x+20, this.y, 0, -10, this.color3);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;


    if (shift === this.shift.min) {
      this.drawArrow(ctx, posX, this.y-40, posX+20, this.y-10-lineWidth, this.color2);
      this.drawTap(ctx, posX, this.y-10, posX, this.y-20, this.color1);

      this.drawArrow(ctx, posX-40, this.y-10, posX-40, this.y-40+lineWidth);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    }
    else {
      this.drawArrow(ctx, posX, this.y-40, posX+20, this.y-10-lineWidth);
      this.drawTap(ctx, posX, this.y-10, posX, this.y-20);

      this.drawArrow(ctx, posX-40, this.y-10, posX-40, this.y-40+lineWidth, this.color1);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20, this.color3);
    }

    this.drawRectangle(ctx, posX-10, this.y-10, posX+30, this.y-40);
    this.drawRectangle(ctx, posX-50, this.y-10, posX-10, this.y-40);
    this.drawSpring(ctx, posX+30, this.y-20);
    this.drawPushRoller(ctx, posX-50, this.y-25);

    ctx.font = textFont;
    ctx.fillStyle = this.color;
    ctx.textAlign = "center";
    ctx.fillText(this.options.reference.slice(0, 3), posX-66, this.y-35);
    ctx.textAlign = "start";
  }
}


class Roller extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Roller';
    this.shift = 0;
    this.maxShift = 10;
    this.color = '#000';
    this.touching = false;
    this.options = {
      reference: '1.1',
    }
  }

  vias() {
    return [];
  }

  reset () {
    this.shift = 0;
  }

  update(ctx, engine, dt) {
    this.shift = 0;
    for (const comp of engine.components) {
      if (['Cylinder1', 'Cylinder2'].includes(comp.type)) {
        if (this.nearCylinder(comp)) {
          this.shift = this.maxShift;
          break;
        }
      }
    }
    for (const comp of engine.components) {
      if (['Valve32r'].includes(comp.type)) {
        if (this.options.reference.slice(0, 3) === comp.options.reference.slice(0, 3)) {
          if (this.shift === 0)
            comp.active = false;
          else
            comp.active = true;
        }
      }
    }
  }

  nearCylinder(cyl) {
    if (cyl.y-35 < this.y + 6 && cyl.y-15 > this.y + 6) {
      if (cyl.x+cyl.shift+120 < this.x && cyl.x+cyl.shift+145 > this.x) {
        return true;
      }
    }
    return false;
  }

  near(pos) {
    return this.nearRect(this.x-15, this.y-40, this.x+15, this.y, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawRectangle(ctx, this.x-15, this.y-40, this.x+15, this.y-20);

    ctx.font = textFont;
    ctx.fillStyle = this.color;
    ctx.textAlign = "center";
    ctx.fillText(this.options.reference.slice(0, 3), this.x, this.y-25);
    ctx.textAlign = "start";

    let posY = this.y - this.shift;
    ctx.beginPath();
    ctx.moveTo(this.x-4, posY-4);
    ctx.lineTo(this.x-4, this.y-20);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(this.x+4, posY-4);
    ctx.lineTo(this.x+4, this.y-20);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(this.x, posY, 6, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(this.x, posY, 1, 0, Math.PI*2);
    ctx.stroke();
  }
}


class Valve52m extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve52m';
    this.shift = {
      min: 0,
      max: 60,
      pos: 0,
      speed: 200,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
    this.color4 = defaultColor;
    this.color5 = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x-20, y:this.y};
    const via3 = {x:this.x+20, y:this.y};
    const via4 = {x:this.x-20, y:this.y-50};
    const via5 = {x:this.x+20, y:this.y-50};
    return [via1, via2, via3, via4, via5];
  }

  reset () {
    this.shift.pos = this.shift.min;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
    this.color4 = defaultColor;
    this.color5 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2, via3, via4, via5] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    const node4 = engine.findNode(via4);
    const node5 = engine.findNode(via5);
    if (this.shift.pos === this.shift.min) {
      this.computeFlow(node1, node5, this.conductance, dt);
      this.computeFlow(node4, node2, this.conductance, dt);
    }
    if (this.shift.pos === this.shift.max) {
      this.computeFlow(node1, node4, this.conductance, dt);
      this.computeFlow(node5, node3, this.conductance, dt);
    }
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
    this.color3 = this.colorPressure(node3.pressure);
    this.color4 = this.colorPressure(node4.pressure);
    this.color5 = this.colorPressure(node5.pressure);
  }

  near(pos) {
    return this.nearRect(this.x-90, this.y-40, this.x+30, this.y-10, pos);
  }

  nearPushButton(pos) {
    if (this.nearRect(this.x-110+this.shift.pos, this.y-35,
                      this.x-90+this.shift.pos, this.y-15, pos))
      return true;
    if (activateValvesTouchingBody)
      return this.near(pos);
    return false;
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x-20, this.y, 0, -10, this.color2);
    this.drawPort(ctx, this.x+20, this.y, 0, -10, this.color3);
    this.drawPort(ctx, this.x-20, this.y-50, 0, 10, this.color4);
    this.drawPort(ctx, this.x+20, this.y-50, 0, 10, this.color5);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    if (shift === this.shift.min) {
      this.drawArrow(ctx, posX, this.y-10, posX+20, this.y-40+lineWidth, this.color1);
      this.drawArrow(ctx, posX-20, this.y-40, posX-20, this.y-10-lineWidth, this.color4);
      this.drawTap(ctx, posX+20, this.y-10, posX+20, this.y-20, this.color3);
      posX -= 60;
      this.drawArrow(ctx, posX, this.y-10, posX-20, this.y-40+lineWidth);
      this.drawArrow(ctx, posX+20, this.y-40, posX+20, this.y-10-lineWidth);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
    }
    else {
      this.drawArrow(ctx, posX, this.y-10, posX+20, this.y-40+lineWidth);
      this.drawArrow(ctx, posX-20, this.y-40, posX-20, this.y-10-lineWidth);
      this.drawTap(ctx, posX+20, this.y-10, posX+20, this.y-20);
      posX -= 60;
      this.drawArrow(ctx, posX, this.y-10, posX-20, this.y-40+lineWidth, this.color1);
      this.drawArrow(ctx, posX+20, this.y-40, posX+20, this.y-10-lineWidth, this.color5);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20, this.color2);
    }

    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);
    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);
    this.drawSpring(ctx, posX+30, this.y-20);
    this.drawPushButton(ctx, posX-30, this.y-20);
  }
}


class Valve52p extends ComponentBase {
  constructor(pos) {
    super(pos);
    this.type = 'Valve52p';
    this.shift = {
      min: 0,
      max: 60,
      pos: 0,
      speed: 200,
    }
    this.conductance = conductanceBase;
    this.active = false;
    this.color = '#000';
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
    this.color4 = defaultColor;
    this.color5 = defaultColor;
    this.color6 = defaultColor;
    this.color7 = defaultColor;
  }

  vias() {
    const via1 = {x:this.x, y:this.y};
    const via2 = {x:this.x-20, y:this.y};
    const via3 = {x:this.x+20, y:this.y};
    const via4 = {x:this.x-20, y:this.y-50};
    const via5 = {x:this.x+20, y:this.y-50};
    const via6 = {x:this.x-110, y:this.y-20};
    const via7 = {x:this.x+110, y:this.y-20};
    return [via1, via2, via3, via4, via5, via6, via7];
  }

  reset () {
    this.shift.pos = this.shift.min;
    this.color1 = defaultColor;
    this.color2 = defaultColor;
    this.color3 = defaultColor;
    this.color4 = defaultColor;
    this.color5 = defaultColor;
    this.color6 = defaultColor;
    this.color7 = defaultColor;
  }

  update(ctx, engine, dt) {
    const [via1, via2, via3, via4, via5, via6, via7] = this.vias();
    const node1 = engine.findNode(via1);
    const node2 = engine.findNode(via2);
    const node3 = engine.findNode(via3);
    const node4 = engine.findNode(via4);
    const node5 = engine.findNode(via5);
    const node6 = engine.findNode(via6);
    const node7 = engine.findNode(via7);

    if (this.active && node7.pressure > node6.pressure + 0.1) {
       this.active = false;
    }
    if (!this.active && node6.pressure > node7.pressure + 0.1) {
       this.active = true;
    }

    if (this.shift.pos === this.shift.min) {
      this.computeFlow(node1, node5, this.conductance, dt);
      this.computeFlow(node4, node2, this.conductance, dt);
    }
    if (this.shift.pos === this.shift.max) {
      this.computeFlow(node1, node4, this.conductance, dt);
      this.computeFlow(node5, node3, this.conductance, dt);
    }
    if (this.active) {
       if (this.shift.pos < this.shift.max)
         this.shift.pos += dt * this.shift.speed;
       if (this.shift.pos > this.shift.max)
         this.shift.pos = this.shift.max;
    }
    else {
       if (this.shift.pos > this.shift.min)
         this.shift.pos -= dt * this.shift.speed;
       if (this.shift.pos < this.shift.min)
         this.shift.pos = this.shift.min;
    }

    // Set colors
    this.color1 = this.colorPressure(node1.pressure);
    this.color2 = this.colorPressure(node2.pressure);
    this.color3 = this.colorPressure(node3.pressure);
    this.color4 = this.colorPressure(node4.pressure);
    this.color5 = this.colorPressure(node5.pressure);
    this.color6 = this.colorPressure(node6.pressure);
    this.color7 = this.colorPressure(node7.pressure);
  }

  near(pos) {
    return this.nearRect(this.x-90, this.y-40, this.x+30, this.y-10, pos);
  }

  draw(ctx) {
    ctx.lineWidth = lineWidth;
    this.drawPort(ctx, this.x, this.y, 0, -10, this.color1);
    this.drawPort(ctx, this.x-20, this.y, 0, -10, this.color2);
    this.drawPort(ctx, this.x+20, this.y, 0, -10, this.color3);
    this.drawPort(ctx, this.x-20, this.y-50, 0, 10, this.color4);
    this.drawPort(ctx, this.x+20, this.y-50, 0, 10, this.color5);
    this.drawPort(ctx, this.x-110, this.y-20, 6, 0, this.color6);
    this.drawPort(ctx, this.x+110, this.y-20, -6, 0, this.color7);
    this.drawBody(ctx, this.shift.pos);
  }

  drawBody(ctx, shift) {
    let posX = this.x + shift;

    if (shift === this.shift.min) {
      this.drawArrow(ctx, posX, this.y-10, posX+20, this.y-40+lineWidth, this.color1);
      this.drawArrow(ctx, posX-20, this.y-40, posX-20, this.y-10-lineWidth, this.color4);
      this.drawTap(ctx, posX+20, this.y-10, posX+20, this.y-20, this.color3);
      posX -= 60;
      this.drawArrow(ctx, posX, this.y-10, posX-20, this.y-40+lineWidth);
      this.drawArrow(ctx, posX+20, this.y-40, posX+20, this.y-10-lineWidth);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20);
      posX += 60;
    }
    else {
      this.drawArrow(ctx, posX, this.y-10, posX+20, this.y-40+lineWidth);
      this.drawArrow(ctx, posX-20, this.y-40, posX-20, this.y-10-lineWidth);
      this.drawTap(ctx, posX+20, this.y-10, posX+20, this.y-20);
      posX -= 60;
      this.drawArrow(ctx, posX, this.y-10, posX-20, this.y-40+lineWidth, this.color1);
      this.drawArrow(ctx, posX+20, this.y-40, posX+20, this.y-10-lineWidth, this.color5);
      this.drawTap(ctx, posX-20, this.y-10, posX-20, this.y-20, this.color2);
      posX += 60;
    }

    ctx.strokeStyle = this.color7;
    ctx.beginPath();
    ctx.moveTo(posX+44, this.y-20);
    ctx.lineTo(this.x+110, this.y-20);
    ctx.stroke();

    this.drawRectangle(ctx, posX+30, this.y-27, posX+44, this.y-13, this.color7);
    ctx.strokeStyle = this.color7;
    ctx.beginPath();
    ctx.moveTo(posX+44, this.y-27);
    ctx.lineTo(posX+34, this.y-20);
    ctx.lineTo(posX+44, this.y-13);
    ctx.stroke();

    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);

    posX -= 60;
    ctx.strokeStyle = this.color6;    
    ctx.beginPath();
    ctx.moveTo(posX-44, this.y-20);
    ctx.lineTo(this.x-110, this.y-20);
    ctx.stroke();

    this.drawRectangle(ctx, posX-30, this.y-27, posX-44, this.y-13, this.color6);
    ctx.strokeStyle = this.color6;
    ctx.beginPath();
    ctx.moveTo(posX-44, this.y-27);
    ctx.lineTo(posX-34, this.y-20);
    ctx.lineTo(posX-44, this.y-13);
    ctx.stroke();

    this.drawRectangle(ctx, posX-30, this.y-40, posX+30, this.y-10);
  }
}


/*************************************************************************/

class Node {
  constructor(pos) {
    this.volume = 10; // cm3
    this.pressure = airPressure; // bar
    this.mass = this.pressure * this.volume;
    this.x = pos.x;
    this.y = pos.y;
  }

  addAir(q) {
    this.mass += q;
    this.pressure = this.mass / this.volume;
  }
}


class Engine {

  constructor() {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.components = [];
    this.nodes = [];
  }

  render(dt) {
    for (const comp of this.components) {
      comp.update(this.ctx, this, dt);
    }
  }

  createNodes() {
    this.nodes = [];
    for (const comp of this.components) {
      for (const pos of comp.vias()) {
        if (this.findNode(pos) === null) {
          const newnode = new Node(pos);
          this.nodes.push(newnode);
        }
      }
    }
  }

  findNode(pos) {
    for (const node of this.nodes) {
      if ((node.x === pos.x) && (node.y === pos.y)) {
        return node;
      }
    }
    return null;
  }

  haveTeacherComp() {
    for (const comp of this.components) {
      if (parseInt(comp.timestamp, 16) <= minTimestamp) {
        return true;
      }
    }
    return false;
  }

  addComponent(comp){
    this.components.push(comp);
  }

  deleteComponent(comp) {
    const index = this.components.indexOf(comp);
    this.components.splice(index, 1);
  }

  reset() {
    this.components = [];
  }

  step(){
  }
}


/*************************************************************************/

class Renderer{
  constructor(canvas, engine){
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.engine = engine;
    this.selectedId = null;
  }

  draw() {
    const ctx = this.ctx;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    ctx.textAlign = "start";
    ctx.font = textFont;
    ctx.fillStyle = '#aaa';
    ctx.fillText('PICUINO PNEUMATIC SIMULATOR V' + programVersion, 8, 18);
    this.drawPosition(mousePosition);

    ctx.lineWidth = lineWidth;
    for (const comp of this.engine.components) {
      comp.draw(ctx);
    }
  }

  drawPosition(position) {
    const ctx = this.ctx;
    if (this.engine.haveTeacherComp()) {
      ctx.fillStyle = '#fff';
    }
    else {
      ctx.fillStyle = '#afa';
    }
    ctx.fillRect(this.canvas.width*0.5-76, 5, 76, 18);
    if (position !== null) {
      ctx.textAlign = 'center';
      ctx.font = textFont;
      ctx.fillStyle = '#aaa';
      ctx.fillText(Math.round(position.x) + ',' + Math.round(position.y),
                   this.canvas.width*0.5-38, 18);
      ctx.textAlign = 'left';
    }
  }
}



/*************************************************************************/

class UIController {
  constructor(canvas, engine, renderer) {
    this.canvas = canvas;
    this.engine = engine;
    this.renderer = renderer;
    this.grid = grid;
    this.offset = {x:0, y:0};
    this.inspector = document.getElementById('props');
    this.pendingPort = null;

    this.canvas.addEventListener('mousedown', e=> this._onDown(e));
    window.addEventListener('mousemove', e=> this._onMove(e));
    window.addEventListener('mouseup', e=> this._onUp(e));
    window.addEventListener("resize", e=> this._resizeCanvas());
    document.addEventListener("keydown", event => {
      if (event.key === "Escape") { this._escape(); }
      if (event.key === "Delete") { this._delete(); }
      if (event.key === "s" || event.key === "S") { simulationStep(); }
      this.renderer.draw();
    });
  }

  _delete() {
    if ((drawMode === 'Move') && (componentMove)) {
       this.engine.deleteComponent(componentMove);
    }
  }

  _escape() {
    drawMode = null;
    componentMove = null;
    if (editPipe) {
      this.engine.deleteComponent(editPipe)
    }
    editPipe = null;
    pipeMove = null;
    initPos = null;
  }

  _resizeCanvas(e) {
    const canvas = this.canvas;
    const ctx = canvas.getContext('2d');
    canvas.width  = window.innerWidth*canvasScale;
    canvas.height = window.innerHeight*canvasScale - 35;
    canvas.style.width = this.canvas.width/canvasScale + 'px';
    canvas.style.height  = this.canvas.height/canvasScale + 'px';
    ctx.scale(canvasScale, canvasScale);
    this.renderer.draw();
  }

  _getMousePos(e) {
    const r = this.canvas.getBoundingClientRect();
    const position = {x:e.clientX - r.left, y:e.clientY - r.top};
    mousePosition = position;
    return position;
  }

  _onDown(e) {
    let position = this._getMousePos(e);

    // Activate manual valves
    for (const comp of this.engine.components) {
      if (['Valve32m', 'Valve22m', 'Valve52m'].includes(comp.type)
          && comp.nearPushButton(position)) {
        if (comp.active) comp.active = false;
        else comp.active = true;
      }
    }

    // Modify component mode
    if (drawMode === 'Modify') {
      for (const comp of this.engine.components) {
        if (comp.near(position)) {
          if (comp.type === 'Text') {
            componentEdit = comp;
            textPromptAssign('text', 'Text:');
            break;
          }
          if (comp.type === 'ValveFlow') {
            componentEdit = comp;
            textPromptAssign('conductance', 'Conductance:');
            break;
          }
          if (['Valve32r', 'Roller'].includes(comp.type)) {
            componentEdit = comp;
            textPromptAssign('reference', 'Reference:');
            break;
          }
          if (comp.type === 'ValveNret') {
            comp.flip();
            break;
          }
        }
      }
      this.renderer.draw();
    }

    // Delete component mode
    if (drawMode === 'Delete') {
      let deleteComp = null;
      for (const comp of this.engine.components) {
        if (comp.near(position)) {
          deleteComp = comp;
          break;
        }
      }
      if (deleteComp) {
        this.engine.deleteComponent(deleteComp);
      }
      this.renderer.draw();
    }


    // Draw component mode
    if (drawMode === 'component') {
      let comp = null;
      if (componentType === 'Compressor') comp = new Compressor(position);
      if (componentType === 'Escape') comp = new Escape(position);
      if (componentType === 'Text') comp = new Text(position);
      if (componentType === 'Cylinder1') comp = new Cylinder1(position);
      if (componentType === 'Cylinder2') comp = new Cylinder2(position);
      if (componentType === 'Valve22m') comp = new Valve22m(position);
      if (componentType === 'Valve32m') comp = new Valve32m(position);
      if (componentType === 'Valve32r') comp = new Valve32r(position);
      if (componentType === 'Roller') comp = new Roller(position);
      if (componentType === 'Valve52m') comp = new Valve52m(position);
      if (componentType === 'Valve52p') comp = new Valve52p(position);
      if (componentType === 'ValveNret') comp = new ValveNret(position);
      if (componentType === 'ValveFlow') comp = new ValveFlow(position);
      if (componentType === 'ValveOr') comp = new ValveOr(position);
      if (componentType === 'ValveAnd') comp = new ValveAnd(position);

      // Draw Text
      if (componentType === 'Text') {
        componentEdit = comp;
        textPromptAssign('text', 'Text:');
      }
      if (['Valve32r', 'Roller'].includes(componentType)) {
        componentEdit = comp;
        textPromptAssign('reference', 'Reference:');
      }

      // Draw pipe
      if (componentType === 'Pipe') {
        if (initPos === null) {
          initPos = position;
          editPipe = new Pipe(initPos, initPos);
          comp = editPipe;
          editPipe.color = selectedColor;
        }
        else {
          editPipe.moveEnd(position);
          editPipe.color = '#000';
          if (editPipe.init.x === editPipe.end.x &&
              editPipe.init.y === editPipe.end.y) {
            this.engine.deleteComponent(editPipe);
          }
          editPipe = null;
          initPos = null;
        }
      }

    // Add component and redraw
      if (comp !== null) {
        this.engine.addComponent(comp);
      }
      this.renderer.draw();
    }

    // Move component mode
    if (drawMode === 'Move') {
      if (componentMove !== null) {
        componentMove.color = '#000';
        if (pipeMove === 'init')
          componentMove.moveInit(position);
        else if (pipeMove === 'end')
          componentMove.moveEnd(position);
        else {
          componentMove.move(position.x, position.y);
        }
        componentMove = null;
        pipeMove = null;
      }
      else {
        for (const comp of this.engine.components) {
          const near = comp.near(position);
          if (near) {
            componentMove = comp;
            componentMove.color = selectedColor;
            if (componentMove.type === 'Pipe') {
              pipeMove = near;
            }
            break;
          }
        }
      }
      this.renderer.draw();
    }
  }

  _onMove(e){
    let position = this._getMousePos(e);

    if ((drawMode === 'component') && (componentType === 'Pipe') && (initPos !== null)) {
      editPipe.moveEnd(position);
      this.renderer.draw();
    }

    if ((drawMode === 'Move') && (componentMove)) {
      if (pipeMove === 'init') {
        componentMove.moveInit(position);
      }
      else if (pipeMove === 'end') {
        componentMove.moveEnd(position);
      }
      else {
        componentMove.move(position.x, position.y);
      }
      this.renderer.draw();
    }
  }

  _onUp(e){
    this.dragging = null;
  }

}

/*************************************************************************/

/*
  cyrb53 (c) 2018 bryc (github.com/bryc)
  License: Public domain (or MIT if needed). Attribution appreciated.
  A fast and simple 53-bit string hash function with decent collision resistance.
  Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
*/
function cyrb53(str, seed = 0) {
  let h1 = 0xdeadbeef ^ seed;
  let h2 = 0x41c6ce57 ^ seed;
  for(let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1  = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
  h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
  h2  = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
  h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
  const hash = 4294967296 * (2097151 & h2) + (h1 >>> 0);
  return hash.toString(16).toUpperCase();
};



/************************ FILE OPERATIONS ************************/

function swapScreen() {
  const elem = document.documentElement;
  if (!document.fullscreenElement) {
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.webkitRequestFullscreen) { /* Safari */
      elem.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { /* IE11 */
      elem.msRequestFullscreen();
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) { /* Safari */
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { /* IE11 */
      document.msExitFullscreen();
    }
  }
}

function aboutWindowShow() {
  console.log('Picuino Pneumatic Simulator v' + programVersion);
  console.log('Copyright © 2025 Carlos Félix Pardo Martín.');
  aboutWindowTitle.innerHTML = 'Picuino Pneumatic Simulator v' + programVersion;
  aboutWindow.showModal();
}

function resetEditor() {
   engine.reset();
   renderer.draw();
}

function loadSchema(schematicJSON) {
  if (!schematicJSON) return;
  const data = JSON.parse(schematicJSON);
  const header = data.slice(0, 1)[0];
  const schematic = data.slice(1, -1);
  const footer = data.slice(-1)[0];
  const hashData = cyrb53(JSON.stringify(data.slice(0, -1)));
  if (footer.hash !== hashData) {
     console.log('Corrupted file!');
     return;
  }

  let components = [];
  for (const comp of schematic) {
    newcomp = null;
    if (comp.type === 'Compressor') newcomp = new Compressor({x:comp.x, y:comp.y});
    if (comp.type === 'Escape')     newcomp = new Escape({x:comp.x, y:comp.y});
    if (comp.type === 'Cylinder1')  newcomp = new Cylinder1({x:comp.x, y:comp.y});
    if (comp.type === 'Cylinder2')  newcomp = new Cylinder2({x:comp.x, y:comp.y});
    if (comp.type === 'Valve22m')   newcomp = new Valve22m({x:comp.x, y:comp.y});
    if (comp.type === 'Valve32m')   newcomp = new Valve32m({x:comp.x, y:comp.y});
    if (comp.type === 'Valve52m')   newcomp = new Valve52m({x:comp.x, y:comp.y});
    if (comp.type === 'Valve52p')   newcomp = new Valve52p({x:comp.x, y:comp.y});
    if (comp.type === 'ValveFlow')  newcomp = new ValveFlow({x:comp.x, y:comp.y});
    if (comp.type === 'ValveOr')    newcomp = new ValveOr({x:comp.x, y:comp.y});
    if (comp.type === 'ValveAnd')   newcomp = new ValveAnd({x:comp.x, y:comp.y});
    if (comp.type === 'Text')       newcomp = new Text({x:comp.x, y:comp.y});
    if (comp.type === 'Valve32r')   newcomp = new Valve32r({x:comp.x, y:comp.y});
    if (comp.type === 'Roller')     newcomp = new Roller({x:comp.x, y:comp.y});
    if (comp.type === 'ValveNret')     newcomp = new ValveNret({x:comp.x, y:comp.y});
    if (comp.type === 'Pipe')       newcomp = new Pipe(comp.init, comp.end);
    if (newcomp) {
      Object.assign(newcomp.options, comp.options);
      newcomp.timestamp = comp.stamp;
      components.push(newcomp);
    }
  }
  engine.components = components;
  renderer.draw();
}


async function openSchema() {
  let schematic = null;
  const input = document.createElement('input');
  input.type = 'file';
  input.onchange = async (e) => {
    const file = e.target.files[0];
    const schematic = await file.text();
    loadSchema(schematic);
  };
  input.click();
  engine.createNodes();
}


async function openFile(filename) {
  try {
    const answer = await fetch(filename);

    if (!answer.ok) {
      throw new Error("Could not read the file");
    }
    const data = await answer.text();
    loadSchema(data);
    engine.createNodes();
  } catch (error) {
    console.error("Error:", error);
  }
}


function savePNG() {
  renderer.draw();

  const dataURL = canvas.toDataURL('image/png');
  const enlaceDescarga = document.createElement('a');
  enlaceDescarga.href = dataURL;
  enlaceDescarga.download = 'neumatic.png';
  enlaceDescarga.style.display = 'none';
  document.body.appendChild(enlaceDescarga);
  enlaceDescarga.click();
  document.body.removeChild(enlaceDescarga);
  URL.revokeObjectURL(enlaceDescarga);
}


function saveSchema(rol) {
  let schematic = [{
    type: 'Schematic',
    program: 'Picuino Pneumatic Simulator',
    version: programVersion,
  }];
  for (const comp of engine.components) {
    let data = comp.serialize();
    if (rol === 'teacher') {
      data.stamp = '1000000000';
    }
    schematic.push(data);
  }
  schematicJSON = JSON.stringify(schematic);
  const hash = cyrb53(schematicJSON);
  schematic.push({type:'hash', hash});
  schematicJSONHash = JSON.stringify(schematic);

  const blob = new Blob([schematicJSONHash], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const enlaceDescarga = document.createElement('a');
  enlaceDescarga.href = url;
  enlaceDescarga.download = 'neumatic.txt';
  enlaceDescarga.style.display = 'none';
  document.body.appendChild(enlaceDescarga);
  enlaceDescarga.click();
  document.body.removeChild(enlaceDescarga);
  URL.revokeObjectURL(url);
}

/************************ SIMULATION ************************/

function simulationInit() {
  drawMode = null;
  engine.createNodes();
  animationID = requestAnimationFrame(simulationRender);
  simulationActive = true;
}

function simulationStep() {
  drawMode = null;
  stepTime = 500;
  if (simulationActive !== true) {
    simulationInit();
  }
  if (animationID === null) {
    animationID = requestAnimationFrame(simulationRender);
  }
}

function simulationStop() {
  drawMode = null;
  if (animationID !== null) {
    cancelAnimationFrame(animationID);
    animationID = null;
  }
}

function simulationContinue() {
  drawMode = null;
  if (animationID === null) {
    animationID = requestAnimationFrame(simulationRender);
  }
}

function simulationReset() {
  simulationStop();
  for (const comp of engine.components) {
    comp.reset();
  }
  engine.createNodes();
  renderer.draw();
  simulationActive = false;
}


function simulationRender(ms) {
  if (ms - simulationTime > 50) {
    simulationTime = ms - 50;
  }
  
  // Ejecutar tantos pasos de 1 ms como quepan en el tiempo acumulado
  while (simulationTime < ms) {
    engine.render(0.001);
    simulationTime += 1;
    if (stepTime && stepTime > 0)
      stepTime -= 1;
  }

  if (stepTime === 0) {
    stepTime = null;
    animationID = null;
  }

  // Aquí solo dibujas el estado actual (una vez por frame)
  renderer.draw();
  
  if (animationID) {
    requestAnimationFrame(simulationRender);
  }
}

let animationID = null;
let simulationTime = performance.now();
let accumulator = 0;


/************************ LANGUAGES ************************/

function setLanguage(lang) {
  if (! ['en', 'es'].includes(lang)) {
    lang = 'en';
  }
  globalLang = lang;
  const elements = document.querySelectorAll("[data-i18n]");
  elements.forEach(el => {
    const key = el.getAttribute("data-i18n");
    const translation = translations[lang][key];
    if (translation) {
      el.textContent = translation;
    }
  });
}

function enLang() {
  globalLang = 'en';
  setLanguage('en');
}

function esLang() {
  globalLang = 'es';
  setLanguage('es');
}

function navigatorLang() {
  const lang = (navigator.language || navigator.userLanguage).substring(0, 2);
  setLanguage(lang)
}


/************************ MAIN ************************/

const aboutWindow = document.getElementById('aboutWindow');
const aboutWindowTitle = document.querySelector('#aboutWindow h2');
const aboutWindowClose = document.getElementById('closeBtn');
const textPrompt = document.getElementById('textPrompt');
const textInput = document.getElementById('textInput');
const messageInput = document.getElementById('messageInput');

const engine = new Engine();
const renderer = new Renderer(canvas, engine);
const ui = new UIController(canvas, engine, renderer);
let last = performance.now();


function firstSetupApp() {
  ui._resizeCanvas();
  navigatorLang();

  let config = query_read();
  for(let i = 0; i < config.length; i++) {
    let line = config[i];
    if (line.length === 2 && line[0] === 'loadFile') {
      openFile('./' + line[1]);
    }
  }
}


firstSetupApp();

aboutWindowClose.onclick = () => aboutWindow.close();


function snap(v, gr=grid) {
  return Math.round(v/gr)*gr;
}


function textPromptAssign(key, message) {
  textPromptDialog(componentEdit.options[key], message);

  textPrompt.addEventListener('close', () => {
    if (textPrompt.returnValue !== 'cancel' && componentEdit) {
      const text = textInput.value.trim();
      if (text.length > 0) {
        componentEdit.options[key] = text;
      }
      componentEdit = null;
      renderer.draw();
    }
  }, { once: true });
}


function textPromptDialog(content='Text', message='Value:') {
  textInput.value = content;
  messageInput.innerText = message;
  textPrompt.showModal();
}


// Read query string from URL
function query_read() {
  var url = document.location.href.split('?');
  if (url.length < 2)
    return [];
  var values = url[1].split('&');
  var vars = [];
  for(i=0; i<values.length; i++) {
    var value = values[i].split('=');
    if (value.length != 2) continue;
    vars.push(value);
  }
  return vars;
}

</script>

</body>
</html>